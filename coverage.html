
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cluster: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mrgb7/playground/cmd/cluster/clean.go (5.0%)</option>
				
				<option value="file1">github.com/mrgb7/playground/cmd/cluster/cluster.go (100.0%)</option>
				
				<option value="file2">github.com/mrgb7/playground/cmd/cluster/create.go (15.2%)</option>
				
				<option value="file3">github.com/mrgb7/playground/cmd/cluster/delete.go (4.0%)</option>
				
				<option value="file4">github.com/mrgb7/playground/cmd/cluster/list.go (0.0%)</option>
				
				<option value="file5">github.com/mrgb7/playground/cmd/cluster/plugin/add.go (0.0%)</option>
				
				<option value="file6">github.com/mrgb7/playground/cmd/cluster/plugin/get.go (0.0%)</option>
				
				<option value="file7">github.com/mrgb7/playground/cmd/cluster/plugin/list.go (0.0%)</option>
				
				<option value="file8">github.com/mrgb7/playground/cmd/cluster/plugin/plugin.go (0.0%)</option>
				
				<option value="file9">github.com/mrgb7/playground/cmd/cluster/plugin/remove.go (0.0%)</option>
				
				<option value="file10">github.com/mrgb7/playground/cmd/root/root.go (0.0%)</option>
				
				<option value="file11">github.com/mrgb7/playground/cmd/root/version.go (0.0%)</option>
				
				<option value="file12">github.com/mrgb7/playground/internal/installer/argo.go (9.1%)</option>
				
				<option value="file13">github.com/mrgb7/playground/internal/installer/helm.go (0.0%)</option>
				
				<option value="file14">github.com/mrgb7/playground/internal/k8s/client.go (0.0%)</option>
				
				<option value="file15">github.com/mrgb7/playground/internal/multipass/client.go (7.8%)</option>
				
				<option value="file16">github.com/mrgb7/playground/internal/plugins/argocd.go (5.7%)</option>
				
				<option value="file17">github.com/mrgb7/playground/internal/plugins/base.go (7.1%)</option>
				
				<option value="file18">github.com/mrgb7/playground/internal/plugins/certmanager.go (12.0%)</option>
				
				<option value="file19">github.com/mrgb7/playground/internal/plugins/ingress.go (1.6%)</option>
				
				<option value="file20">github.com/mrgb7/playground/internal/plugins/loadbalancer.go (3.3%)</option>
				
				<option value="file21">github.com/mrgb7/playground/internal/plugins/nginx.go (65.4%)</option>
				
				<option value="file22">github.com/mrgb7/playground/internal/plugins/plugin.go (36.4%)</option>
				
				<option value="file23">github.com/mrgb7/playground/internal/plugins/tls.go (1.7%)</option>
				
				<option value="file24">github.com/mrgb7/playground/internal/plugins/utils.go (34.3%)</option>
				
				<option value="file25">github.com/mrgb7/playground/main.go (0.0%)</option>
				
				<option value="file26">github.com/mrgb7/playground/pkg/logger/logger.go (60.0%)</option>
				
				<option value="file27">github.com/mrgb7/playground/types/Cluster.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cluster

import (
        "sync"

        "github.com/mrgb7/playground/internal/multipass"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
)

var (
        cPurge bool
)

var cleanCmd = &amp;cobra.Command{
        Use:   "clean",
        Short: "Clean up cluster resources",
        Long:  `Clean up cluster resources, including stopping and removing nodes`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                var wg sync.WaitGroup
                client := multipass.NewMultipassClient()

                if !client.IsMultipassInstalled() </span><span class="cov0" title="0">{
                        logger.Errorln("Error: Multipass is not installed or not in PATH. Please install Multipass first.")
                        return
                }</span>

                <span class="cov0" title="0">if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        clusterName := args[0]
                        logger.Infoln("Cleaning up resources for cluster '%s'...", clusterName)

                        if err := client.DeleteCluster(clusterName, &amp;wg); err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("Failed to clean up cluster: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">wg.Wait()

                        logger.Successln("Successfully cleaned up cluster '%s'", clusterName)</span>
                }

                <span class="cov0" title="0">if cPurge || len(args) == 0 </span><span class="cov0" title="0">{
                        logger.Infoln("Purging all deleted instances...")
                        if err := client.PurgeNodes(); err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("Failed to purge deleted instances: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Successln("Successfully purged all deleted instances")</span>
                }
        },
}

func init() <span class="cov8" title="1">{
        cleanCmd.Flags().BoolVarP(&amp;cPurge, "purge", "p", false, "Purge all resources")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cluster

import (
        "github.com/mrgb7/playground/cmd/cluster/plugin"
        "github.com/spf13/cobra"
)

var ClusterCmd = &amp;cobra.Command{
        Use:   "cluster",
        Short: "Manage clusters",
        Long:  `Commands to create, delete, and get information about clusters`,
}

func init() <span class="cov8" title="1">{
        ClusterCmd.AddCommand(plugin.PluginCmd)
        ClusterCmd.AddCommand(createCmd)
        ClusterCmd.AddCommand(deleteCmd)
        ClusterCmd.AddCommand(cleanCmd)
        ClusterCmd.AddCommand(listCmd)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cluster

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "sync"

        "github.com/mrgb7/playground/internal/multipass"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/clientcmd/api"
        "k8s.io/client-go/util/homedir"
)

// ClusterConfig holds the configuration for cluster creation
type ClusterConfig struct {
        Name               string
        Size               int
        WithCoreComponents bool
        MasterCPUs         int
        MasterMemory       string
        MasterDisk         string
        WorkerCPUs         int
        WorkerMemory       string
        WorkerDisk         string
}

// workerError represents an error that occurred while configuring a worker node
type workerError struct {
        nodeName string
        err      error
}

var (
        cCreateName        string
        cCreateSize        int
        withCoreComponents bool
        masterCPUs         int
        masterMemory       string
        masterDisk         string
        workerCPUs         int
        workerMemory       string
        workerDisk         string
)

const (
        K3sCreateMasterCmd   = `curl -sfL https://get.k3s.io | sh -s - --disable=servicelb --disable=traefik`
        GetAccessTokenCmd    = `sudo cat /var/lib/rancher/k3s/server/node-token` //nolint:gosec
        K3sCreateWorkerCmd   = `curl -sfL https://get.k3s.io | K3S_URL=https://%s:6443 K3S_TOKEN=%s  sh -`
        KubeConfigCmd        = `sudo cat /etc/rancher/k3s/k3s.yaml`
        K3sInstallTimeout    = 300 // seconds - timeout for K3s installation
        MaxClusterSize       = 10  // maximum number of nodes allowed in cluster
        MaxClusterNameLength = 63  // maximum length for cluster name (DNS label limit)
        MinClusterSize       = 1   // minimum number of nodes in cluster
        DefaultMasterCPUs    = 2   // default number of CPUs for master node
        DefaultWorkerCPUs    = 2   // default number of CPUs for worker nodes
        MaxCPUCount          = 32  // maximum number of CPUs per node
)

func validateClusterName(name string) error <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster name cannot be empty")
        }</span>

        <span class="cov0" title="0">matched, err := regexp.MatchString(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`, name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error validating cluster name: %w", err)
        }</span>

        <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster name must start and end with alphanumeric characters " +
                        "and contain only lowercase letters, numbers, and hyphens")
        }</span>

        <span class="cov0" title="0">if len(name) &gt; MaxClusterNameLength </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster name must be %d characters or less", MaxClusterNameLength)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func validateClusterSize(size int) error <span class="cov0" title="0">{
        if size &lt; MinClusterSize </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster size must be at least %d", MinClusterSize)
        }</span>

        <span class="cov0" title="0">if size &gt; MaxClusterSize </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster size cannot exceed %d nodes", MaxClusterSize)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func validateCPUCount(cpus int, nodeType string) error <span class="cov8" title="1">{
        if cpus &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("%s CPU count must be at least 1", nodeType)
        }</span>
        <span class="cov8" title="1">if cpus &gt; MaxCPUCount </span><span class="cov8" title="1">{
                return fmt.Errorf("%s CPU count cannot exceed %d", nodeType, MaxCPUCount)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateMemoryFormat(memory, nodeType string) error <span class="cov8" title="1">{
        matched, err := regexp.MatchString(`^[0-9]+[GM]$`, memory)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error validating %s memory format: %w", nodeType, err)
        }</span>
        <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                return fmt.Errorf("%s memory must be in format like '2G' or '1024M'", nodeType)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateDiskFormat(disk, nodeType string) error <span class="cov8" title="1">{
        matched, err := regexp.MatchString(`^[0-9]+[GMT]$`, disk)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error validating %s disk format: %w", nodeType, err)
        }</span>
        <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                return fmt.Errorf("%s disk must be in format like '20G', '1024M', or '1T'", nodeType)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

var createCmd = &amp;cobra.Command{
        Use:   "create",
        Short: "Create a new cluster",
        Long:  `Create a new cluster with the specified configurations`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                config := &amp;ClusterConfig{
                        Name:               cCreateName,
                        Size:               cCreateSize,
                        WithCoreComponents: withCoreComponents,
                        MasterCPUs:         masterCPUs,
                        MasterMemory:       masterMemory,
                        MasterDisk:         masterDisk,
                        WorkerCPUs:         workerCPUs,
                        WorkerMemory:       workerMemory,
                        WorkerDisk:         workerDisk,
                }

                if err := createCluster(config); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Failed to create cluster: %v", err)
                        return
                }</span>
        },
}

func createCluster(config *ClusterConfig) error <span class="cov0" title="0">{
        if err := validateClusterName(config.Name); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cluster name: %w", err)
        }</span>

        <span class="cov0" title="0">if err := validateClusterSize(config.Size); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cluster size: %w", err)
        }</span>

        <span class="cov0" title="0">if err := validateCPUCount(config.MasterCPUs, "master"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid master CPU count: %w", err)
        }</span>

        <span class="cov0" title="0">if err := validateMemoryFormat(config.MasterMemory, "master"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid master memory format: %w", err)
        }</span>

        <span class="cov0" title="0">if err := validateDiskFormat(config.MasterDisk, "master"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid master disk format: %w", err)
        }</span>

        <span class="cov0" title="0">if err := validateCPUCount(config.WorkerCPUs, "worker"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid worker CPU count: %w", err)
        }</span>

        <span class="cov0" title="0">if err := validateMemoryFormat(config.WorkerMemory, "worker"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid worker memory format: %w", err)
        }</span>

        <span class="cov0" title="0">if err := validateDiskFormat(config.WorkerDisk, "worker"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid worker disk format: %w", err)
        }</span>

        <span class="cov0" title="0">client := multipass.NewMultipassClient()
        if !client.IsMultipassInstalled() </span><span class="cov0" title="0">{
                return fmt.Errorf("multipass is not installed or not in PATH")
        }</span>

        <span class="cov0" title="0">return executeClusterCreation(client, config)</span>
}

func executeClusterCreation(client multipass.Client, config *ClusterConfig) error <span class="cov0" title="0">{
        var wg sync.WaitGroup

        if err := client.CreateCluster(
                config.Name, config.Size, config.MasterCPUs, config.MasterMemory, config.MasterDisk,
                config.WorkerCPUs, config.WorkerMemory, config.WorkerDisk, &amp;wg,
        ); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create cluster: %w", err)
        }</span>

        <span class="cov0" title="0">masterNodeName := fmt.Sprintf("%s-master", config.Name)

        // Install K3s on master node
        if err := installMasterNode(client, masterNodeName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install K3s on master: %w", err)
        }</span>

        // Get access token and master IP
        <span class="cov0" title="0">accessToken, masterIP, err := getMasterCredentials(client, masterNodeName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get master credentials: %w", err)
        }</span>

        // Configure worker nodes
        <span class="cov0" title="0">workerErrors := configureWorkerNodes(client, config, masterIP, accessToken)

        // Report results
        reportClusterCreationResults(config, workerErrors)

        // Update kubeconfig
        return updateKubeConfig(client, masterNodeName, config.Name)</span>
}

func installMasterNode(client multipass.Client, masterNodeName string) error <span class="cov0" title="0">{
        std, err := client.ExecuteShellWithTimeout(masterNodeName, K3sCreateMasterCmd, K3sInstallTimeout)
        if err != nil || std == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create k3s on master: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getMasterCredentials(client multipass.Client, masterNodeName string) (string, string, error) <span class="cov0" title="0">{
        accessToken, err := client.ExecuteShell(masterNodeName, GetAccessTokenCmd)
        if err != nil || accessToken == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to get access token: %w", err)
        }</span>
        <span class="cov0" title="0">accessToken = strings.TrimSpace(accessToken)

        masterIP, err := client.GetNodeIP(masterNodeName)
        if err != nil || masterIP == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to get master node IP: %w", err)
        }</span>

        <span class="cov0" title="0">return accessToken, masterIP, nil</span>
}

func configureWorkerNodes(client multipass.Client, config *ClusterConfig, masterIP, accessToken string) []workerError <span class="cov0" title="0">{
        workerErrors := make([]workerError, 0)
        var workerErrorsMutex sync.Mutex
        var wg sync.WaitGroup

        for i := 0; i &lt; config.Size-1; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(i int) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        nodeName := fmt.Sprintf("%s-worker-%d", config.Name, i+1)
                        _, err := client.ExecuteShellWithTimeout(
                                nodeName,
                                fmt.Sprintf(K3sCreateWorkerCmd, masterIP, accessToken),
                                K3sInstallTimeout,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                workerErrorsMutex.Lock()
                                workerErrors = append(workerErrors, workerError{
                                        nodeName: nodeName,
                                        err:      err,
                                })
                                workerErrorsMutex.Unlock()
                                logger.Errorln("Failed to install K3S on worker node %s: %v", nodeName, err)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Successf("Successfully configured worker node: %s\n", nodeName)
                        }</span>
                }(i)
        }
        <span class="cov0" title="0">wg.Wait()

        return workerErrors</span>
}

func reportClusterCreationResults(config *ClusterConfig, workerErrors []workerError) <span class="cov0" title="0">{
        if len(workerErrors) &gt; 0 </span><span class="cov0" title="0">{
                logger.Warnln("Some worker nodes failed to configure properly:")
                for _, we := range workerErrors </span><span class="cov0" title="0">{
                        logger.Errorln("  - %s: %v", we.nodeName, we.err)
                }</span>
                <span class="cov0" title="0">logger.Warnln("Cluster created with %d/%d worker nodes successfully configured",
                        config.Size-1-len(workerErrors), config.Size-1)</span>
        } else<span class="cov0" title="0"> {
                logger.Successln("Successfully created cluster '%s' with %d nodes", config.Name, config.Size)
        }</span>
}

func updateKubeConfig(client multipass.Client, masterNodeName, clusterName string) error <span class="cov0" title="0">{
        logger.Infoln("Attempting to update kubeconfig...")

        kubConfig, err := client.ExecuteShell(masterNodeName, KubeConfigCmd)
        if err != nil || kubConfig == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get kube config: %w", err)
        }</span>

        // Get master IP to replace 127.0.0.1 in kubeconfig
        <span class="cov0" title="0">masterIP, err := client.GetNodeIP(masterNodeName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get master IP: %w", err)
        }</span>

        // Replace localhost with master IP
        <span class="cov0" title="0">kubConfig = strings.ReplaceAll(kubConfig, "127.0.0.1", masterIP)

        if err := createKubeConfigFile(kubConfig, clusterName); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Failed to update kubeconfig: %v", err)
                logger.Warnln("Cluster created successfully, but kubeconfig update failed.")
                logger.Infof("You can manually retrieve the kubeconfig using: playground cluster kubeconfig --name %s\n", clusterName)
                return err
        }</span>

        <span class="cov0" title="0">logger.Successln("Successfully updated kubeconfig.")
        return nil</span>
}

func createKubeConfigFile(kubeConfig, clusterName string) error <span class="cov0" title="0">{
        // Use client-go to properly parse the K3s kubeconfig format
        newConfig, err := clientcmd.Load([]byte(kubeConfig))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse new kubeconfig: %w", err)
        }</span>

        // Update context and cluster names to include cluster name
        <span class="cov0" title="0">contextName := fmt.Sprintf("%s-context", clusterName)
        clusterKey := fmt.Sprintf("%s-cluster", clusterName)
        userKey := fmt.Sprintf("%s-user", clusterName)

        // Rename the default entries to use cluster-specific names
        if cluster, exists := newConfig.Clusters["default"]; exists </span><span class="cov0" title="0">{
                delete(newConfig.Clusters, "default")
                newConfig.Clusters[clusterKey] = cluster
        }</span>

        <span class="cov0" title="0">if authInfo, exists := newConfig.AuthInfos["default"]; exists </span><span class="cov0" title="0">{
                delete(newConfig.AuthInfos, "default")
                newConfig.AuthInfos[userKey] = authInfo
        }</span>

        <span class="cov0" title="0">if context, exists := newConfig.Contexts["default"]; exists </span><span class="cov0" title="0">{
                delete(newConfig.Contexts, "default")
                context.Cluster = clusterKey
                context.AuthInfo = userKey
                newConfig.Contexts[contextName] = context
        }</span>

        // Set current context to the new cluster
        <span class="cov0" title="0">newConfig.CurrentContext = contextName

        kubeconfigPath := filepath.Join(homedir.HomeDir(), ".kube", "config")
        var existingConfig *api.Config

        if _, err := os.Stat(kubeconfigPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                existingConfig = api.NewConfig()
        }</span> else<span class="cov0" title="0"> {
                existingConfig, err = clientcmd.LoadFromFile(kubeconfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load existing kubeconfig: %w", err)
                }</span>
        }

        // Merge configurations
        <span class="cov0" title="0">for name, cluster := range newConfig.Clusters </span><span class="cov0" title="0">{
                existingConfig.Clusters[name] = cluster
        }</span>

        <span class="cov0" title="0">for name, authInfo := range newConfig.AuthInfos </span><span class="cov0" title="0">{
                existingConfig.AuthInfos[name] = authInfo
        }</span>

        <span class="cov0" title="0">for name, context := range newConfig.Contexts </span><span class="cov0" title="0">{
                existingConfig.Contexts[name] = context
        }</span>

        // Set current context to the new cluster
        <span class="cov0" title="0">existingConfig.CurrentContext = contextName

        if err := clientcmd.WriteToFile(*existingConfig, kubeconfigPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write merged kubeconfig: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        createCmd.Flags().StringVarP(&amp;cCreateName, "name", "n", "", "Name for the cluster (required)")
        createCmd.Flags().IntVarP(&amp;cCreateSize, "size", "s", 1, "Number of nodes in the cluster")
        createCmd.Flags().BoolVarP(&amp;withCoreComponents, "with-core-component", "c", false,
                "Install core components (nginx,cert-manager)")
        createCmd.Flags().IntVarP(&amp;masterCPUs, "master-cpus", "m", DefaultMasterCPUs, "Number of CPUs for the master node")
        createCmd.Flags().StringVarP(&amp;masterMemory, "master-memory", "M", "2G", "Memory for the master node")
        createCmd.Flags().StringVarP(&amp;masterDisk, "master-disk", "D", "20G", "Disk for the master node")
        createCmd.Flags().IntVarP(&amp;workerCPUs, "worker-cpus", "w", DefaultWorkerCPUs, "Number of CPUs for each worker node")
        createCmd.Flags().StringVarP(&amp;workerMemory, "worker-memory", "W", "2G", "Memory for each worker node")
        createCmd.Flags().StringVarP(&amp;workerDisk, "worker-disk", "d", "20G", "Disk for each worker node")
        if err := createCmd.MarkFlagRequired("name"); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Failed to mark name flag as required: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cluster

import (
        "sync"

        "github.com/mrgb7/playground/internal/multipass"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
)

var (
        cDeleteForce bool
        deleteCmd    = &amp;cobra.Command{
                Use:   "delete",
                Short: "Delete an existing cluster",
                Long:  `Delete an existing cluster by specifying its name`,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        var wg sync.WaitGroup
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                logger.Errorln("Error: Cluster name is required")
                                if err := cmd.Help(); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorln("Failed to show help: %v", err)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">clusterToDelete := args[0]

                        client := multipass.NewMultipassClient()

                        if !client.IsMultipassInstalled() </span><span class="cov0" title="0">{
                                logger.Errorln("Error: Multipass is not installed or not in PATH. Please install Multipass first.")
                                return
                        }</span>

                        <span class="cov0" title="0">if clusterToDelete == "" </span><span class="cov0" title="0">{
                                logger.Errorln("Error: Please provide a valid cluster name to delete.")
                                return
                        }</span>
                        <span class="cov0" title="0">if err := client.DeleteCluster(clusterToDelete, &amp;wg); err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("Failed to delete cluster: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">wg.Wait()

                        if cDeleteForce </span><span class="cov0" title="0">{
                                logger.Infoln("Purging deleted instances...")
                                if err := client.PurgeNodes(); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorln("Failed to purge deleted instances: %v", err)
                                        return
                                }</span>

                        }

                        <span class="cov0" title="0">logger.Successln("Successfully deleted cluster '%s'", clusterToDelete)</span>
                },
        }
)

func init() <span class="cov8" title="1">{
        deleteCmd.Flags().BoolVarP(&amp;cDeleteForce, "force", "f", false, "Force delete cluster resources")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package cluster

import (
        "github.com/mrgb7/playground/internal/multipass"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
)

var listCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all existing clusters",
        Long:  `List all existing clusters by finding multipass instances ending with '-master'`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                client := multipass.NewMultipassClient()

                if !client.IsMultipassInstalled() </span><span class="cov0" title="0">{
                        logger.Errorln("Error: Multipass is not installed or not in PATH. Please install Multipass first.")
                        return
                }</span>

                <span class="cov0" title="0">clusters, err := client.ListClusters()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Failed to list clusters: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">if len(clusters) == 0 </span><span class="cov0" title="0">{
                        logger.Infoln("No clusters found.")
                        return
                }</span>

                <span class="cov0" title="0">logger.Infoln("Available clusters:")
                for _, cluster := range clusters </span><span class="cov0" title="0">{
                        logger.Infoln("  - %s", cluster)
                }</span>
        },
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package plugin

import (
        "github.com/mrgb7/playground/internal/plugins"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
)

var (
        pName string
        cName string
)

var addCmd = &amp;cobra.Command{
        Use:   "add",
        Short: "Add a new plugin",
        Long:  `Add a new plugin to the cluster`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                installOperation := func(plugin plugins.Plugin, kubeConfig, clusterName string) error </span><span class="cov0" title="0">{
                        return plugin.Install(kubeConfig, clusterName)
                }</span>

                <span class="cov0" title="0">_ = executePluginOperation(pName, cName, installOperation,
                        "Successfully installed %s", "Error installing plugin")</span>
        },
}

func init() <span class="cov0" title="0">{
        flags := addCmd.Flags()
        flags.StringVarP(&amp;pName, "name", "n", "", "Name of the plugin")
        flags.StringVarP(&amp;cName, "cluster", "c", "", "Name of the cluster")
        if err := addCmd.MarkFlagRequired("name"); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Failed to mark name flag as required: %v", err)
        }</span>
        <span class="cov0" title="0">if err := addCmd.MarkFlagRequired("cluster"); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Failed to mark cluster flag as required: %v", err)
        }</span>
        <span class="cov0" title="0">PluginCmd.AddCommand(addCmd)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package plugin

import (
        "github.com/mrgb7/playground/internal/plugins"
        "github.com/spf13/cobra"
)

var getCmd = &amp;cobra.Command{
        Use:   "get",
        Short: "Get a plugin",
        Long:  "Get a plugin for the cluster",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        found := false
                        for _, plugin := range plugins.List </span><span class="cov0" title="0">{
                                if plugin.GetName() == args[0] </span><span class="cov0" title="0">{
                                        println(plugin.GetName())
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                println("Plugin not found", args[0])
                        }</span>
                }
        },
}

func init() <span class="cov0" title="0">{
        PluginCmd.AddCommand(getCmd)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package plugin

import (
        "github.com/mrgb7/playground/internal/plugins"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/mrgb7/playground/types"
        "github.com/spf13/cobra"
)

var listCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all available plugins",
        Long:  `List all available plugins for the cluster`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                clusterName, _ := cmd.Flags().GetString("cluster-name")
                if clusterName == "" </span><span class="cov0" title="0">{
                        logger.Infoln("Basic plugins:")
                        for _, plugin := range plugins.List </span><span class="cov0" title="0">{
                                logger.Infoln("  %s: %s", plugin.GetName(), plugin.Status())
                        }</span>
                        <span class="cov0" title="0">logger.Infoln("")
                        logger.Infoln("For cluster-specific plugins, specify --cluster-name")
                        return</span>
                }

                <span class="cov0" title="0">c := types.Cluster{
                        Name: clusterName,
                }

                ip := c.GetMasterIP()
                if err := c.SetKubeConfig(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Failed to set kubeconfig: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">pluginsList, err := plugins.CreatePluginsList(c.KubeConfig, ip, c.Name)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Failed to create plugins list: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">logger.Infoln("Available plugins for cluster '%s':", clusterName)
                for _, plugin := range pluginsList </span><span class="cov0" title="0">{
                        logger.Infoln("  %s: %s", plugin.GetName(), plugin.Status())
                }</span>
        },
}

func init() <span class="cov0" title="0">{
        listCmd.Flags().StringP("cluster-name", "c", "", "Cluster name to list plugins for")
        PluginCmd.AddCommand(listCmd)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package plugin

import (
        "github.com/mrgb7/playground/internal/plugins"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/mrgb7/playground/types"
        "github.com/spf13/cobra"
)

var PluginCmd = &amp;cobra.Command{
        Use:   "plugin",
        Short: "Manage plugins",
        Long:  `Manage plugins for the cluster`,
}

// pluginOperation defines the type of operation to perform on a plugin
type pluginOperation func(plugin plugins.Plugin, kubeConfig, clusterName string) error

// executePluginOperation is a common function to handle plugin operations
func executePluginOperation(pluginName, clusterName string, operation pluginOperation,
        successMsg, errorMsg string) error <span class="cov0" title="0">{
        c := types.Cluster{
                Name: clusterName,
        }

        ip := c.GetMasterIP()
        if err := c.SetKubeConfig(); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Failed to set kubeconfig: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">pluginsList, err := plugins.CreatePluginsList(c.KubeConfig, ip, c.Name)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Failed to create plugins list: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">for _, plugin := range pluginsList </span><span class="cov0" title="0">{
                if plugin.GetName() == pluginName </span><span class="cov0" title="0">{
                        err := operation(plugin, c.KubeConfig, c.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("%s: %v", errorMsg, err)
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Successln(successMsg, pluginName)
                        return nil</span>
                }
        }

        <span class="cov0" title="0">logger.Errorln("Plugin %s not found", pluginName)
        logger.Infoln("Available plugins:")
        for _, plugin := range pluginsList </span><span class="cov0" title="0">{
                logger.Infoln("  - %s", plugin.GetName())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package plugin

import (
        "github.com/mrgb7/playground/internal/plugins"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
)

var removeCmd = &amp;cobra.Command{
        Use:   "remove",
        Short: "remove plugin",
        Long:  `Remove plugin from the cluster`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                uninstallOperation := func(plugin plugins.Plugin, kubeConfig, clusterName string) error </span><span class="cov0" title="0">{
                        return plugin.Uninstall(kubeConfig, clusterName)
                }</span>

                <span class="cov0" title="0">_ = executePluginOperation(pName, cName, uninstallOperation,
                        "Successfully uninstalled %s", "Error uninstalling plugin")</span>
        },
}

func init() <span class="cov0" title="0">{
        flags := removeCmd.Flags()
        flags.StringVarP(&amp;pName, "name", "n", "", "Name of the plugin")
        flags.StringVarP(&amp;cName, "cluster", "c", "", "Name of the cluster")
        if err := removeCmd.MarkFlagRequired("name"); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Failed to mark name flag as required: %v", err)
        }</span>
        <span class="cov0" title="0">if err := removeCmd.MarkFlagRequired("cluster"); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Failed to mark cluster flag as required: %v", err)
        }</span>
        <span class="cov0" title="0">PluginCmd.AddCommand(removeCmd)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package root

import (
        "os"

        "github.com/mrgb7/playground/cmd/cluster"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{
        Use:   "playground",
        Short: "A brief description of your application",
        Long: `A longer description that spans multiple lines and likely contains
examples and usage of using your application.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                logger.Infoln("Hello from playground CLI!")
        }</span>,
}

func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Error: %v", err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
        rootCmd.AddCommand(cluster.ClusterCmd)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package root

import (
        "fmt"
        "runtime"

        "github.com/spf13/cobra"
)

var (
        // Version will be set at build time
        Version = "dev"
        // GitCommit will be set at build time
        GitCommit = "unknown"
        // BuildDate will be set at build time
        BuildDate = "unknown"
)

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print the version number of playground",
        Long:  `All software has versions. This is playground's.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Printf("playground version %s\n", Version)
                if verbose, _ := cmd.Flags().GetBool("verbose"); verbose </span><span class="cov0" title="0">{
                        fmt.Printf("Git commit: %s\n", GitCommit)
                        fmt.Printf("Build date: %s\n", BuildDate)
                        fmt.Printf("Go version: %s\n", runtime.Version())
                        fmt.Printf("OS/Arch: %s/%s\n", runtime.GOOS, runtime.GOARCH)
                }</span>
        },
}

func init() <span class="cov0" title="0">{
        versionCmd.Flags().BoolP("verbose", "v", false, "Show verbose version information")
        rootCmd.AddCommand(versionCmd)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package installer

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/client-go/tools/portforward"
        "k8s.io/client-go/transport/spdy"
)

type ArgoInstaller struct {
        KubeConfig     string
        ClusterName    string
        ArgoNamespace  string
        ArgoServerPort int
        LocalPort      int
        ServerAddress  string
        k8sClient      *k8s.K8sClient
        httpClient     *http.Client
        authToken      string
        stopChannel    chan struct{}
        readyChannel   chan struct{}
}

type ArgoApplication struct {
        APIVersion string              `json:"apiVersion"`
        Kind       string              `json:"kind"`
        Metadata   ArgoMetadata        `json:"metadata"`
        Spec       ArgoApplicationSpec `json:"spec"`
}

type ArgoMetadata struct {
        Name      string `json:"name"`
        Namespace string `json:"namespace"`
}

type ArgoApplicationSpec struct {
        Project     string          `json:"project"`
        Source      ArgoSource      `json:"source"`
        Destination ArgoDestination `json:"destination"`
        SyncPolicy  *ArgoSyncPolicy `json:"syncPolicy,omitempty"`
}

type ArgoSource struct {
        RepoURL        string  `json:"repoURL"`
        Path           string  `json:"path"`
        TargetRevision string  `json:"targetRevision"`
        Chart          *string `json:"chart,omitempty"` // Optional, used for Helm charts
        Helm           struct {
                ReleaseName  string `json:"releaseName,omitempty"`
                ValuesObject map[string]interface{}
        } `json:"helm,omitempty"` // Optional, used for Helm charts
}

type ArgoDestination struct {
        Server    string `json:"server"`
        Namespace string `json:"namespace"`
}

type ArgoSyncPolicy struct {
        Automated   *ArgoSyncPolicyAutomated `json:"automated,omitempty"`
        SyncOptions []string                 `json:"syncOptions,omitempty"`
}

type ArgoSyncPolicyAutomated struct {
        Prune    bool `json:"prune,omitempty"`
        SelfHeal bool `json:"selfHeal,omitempty"`
}

type ArgoSessionRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

type ArgoSessionResponse struct {
        Token string `json:"token"`
}

const (
        DefaultArgoNamespace  = "argocd"
        DefaultArgoServerPort = 443
        DefaultLocalPort      = 8080
)

func NewArgoInstaller(kubeConfig, clusterName string) (*ArgoInstaller, error) <span class="cov8" title="1">{
        k8sClient, err := k8s.NewK8sClient(kubeConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create k8s client: %w", err)
        }</span>

        <span class="cov8" title="1">httpClient := &amp;http.Client{
                Timeout: 30 * time.Second,
                Transport: &amp;http.Transport{
                        // This is for local development with port forwarding to ArgoCD
                        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true}, //nolint:gosec
                },
        }

        return &amp;ArgoInstaller{
                KubeConfig:     kubeConfig,
                ClusterName:    clusterName,
                ArgoNamespace:  DefaultArgoNamespace,
                ArgoServerPort: DefaultArgoServerPort,
                LocalPort:      DefaultLocalPort,
                k8sClient:      k8sClient,
                httpClient:     httpClient,
        }, nil</span>
}

func (a *ArgoInstaller) Install(options *InstallOptions) error <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">logger.Infoln("Starting ArgoCD application installation...")

        if err := a.connectToArgoCD(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to ArgoCD: %w", err)
        }</span>
        <span class="cov0" title="0">defer a.cleanup()

        if err := a.createApplication(options); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create ArgoCD application: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Infoln("Successfully created ArgoCD application: %s", options.ApplicationName)
        return nil</span>
}

func (a *ArgoInstaller) UnInstall(options *InstallOptions) error <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">logger.Infoln("Starting ArgoCD application uninstallation...")

        if err := a.connectToArgoCD(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to ArgoCD: %w", err)
        }</span>
        <span class="cov0" title="0">defer a.cleanup()

        if err := a.deleteApplication(options); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete ArgoCD application: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Infoln("Successfully deleted ArgoCD application: %s", options.ApplicationName)
        return nil</span>
}

func (a *ArgoInstaller) connectToArgoCD() error <span class="cov0" title="0">{
        password, err := a.GetAdminPassword()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get admin password: %w", err)
        }</span>

        <span class="cov0" title="0">if err := a.setupPortForward(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup port forward: %w", err)
        }</span>

        // Wait a bit longer for the port forward to be fully established
        <span class="cov0" title="0">logger.Infoln("Waiting for port forward to stabilize...")
        time.Sleep(5 * time.Second)

        // Retry authentication with backoff
        var authErr error
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                authErr = a.authenticate(password)
                if authErr == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">logger.Warnln("Authentication attempt %d failed: %v, retrying...", i+1, authErr)
                time.Sleep(time.Duration(i+1) * 2 * time.Second)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("failed to authenticate after 3 attempts: %w", authErr)</span>
}

func (a *ArgoInstaller) authenticate(password string) error <span class="cov0" title="0">{
        sessionReq := ArgoSessionRequest{
                Username: "admin",
                Password: password,
        }

        reqBody, err := json.Marshal(sessionReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal session request: %w", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("http://%s/api/v1/session", a.ServerAddress)
        req, err := http.NewRequestWithContext(context.Background(), "POST", url, bytes.NewBuffer(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create session request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to authenticate: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debugln("Failed to close response body: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("authentication failed: HTTP %d - %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var sessionResp ArgoSessionResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;sessionResp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode session response: %w", err)
        }</span>

        <span class="cov0" title="0">a.authToken = sessionResp.Token
        return nil</span>
}

func (a *ArgoInstaller) createApplication(options *InstallOptions) error <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">app := ArgoApplication{
                APIVersion: "argoproj.io/v1alpha1",
                Kind:       "Application",
                Metadata: ArgoMetadata{
                        Name:      options.ApplicationName,
                        Namespace: a.ArgoNamespace,
                },
                Spec: ArgoApplicationSpec{
                        Project: "default",
                        Source: ArgoSource{
                                RepoURL:        options.RepoURL,
                                Path:           options.Path,
                                TargetRevision: options.Version,
                        },
                        Destination: ArgoDestination{
                                Server:    "https://kubernetes.default.svc",
                                Namespace: options.Namespace,
                        },
                        SyncPolicy: &amp;ArgoSyncPolicy{
                                Automated: &amp;ArgoSyncPolicyAutomated{
                                        Prune:    true,
                                        SelfHeal: true,
                                },
                                SyncOptions: []string{"CreateNamespace=true"},
                        },
                },
        }
        if options.ChartName != nil </span><span class="cov0" title="0">{
                app.Spec.Source.Chart = options.ChartName
                app.Spec.Source.Helm.ReleaseName = options.ApplicationName
                app.Spec.Source.Helm.ValuesObject = options.Values
        }</span>

        <span class="cov0" title="0">if app.Spec.Source.Path == "" </span><span class="cov0" title="0">{
                app.Spec.Source.Path = "."
        }</span>
        <span class="cov0" title="0">if app.Spec.Source.TargetRevision == "" </span><span class="cov0" title="0">{
                app.Spec.Source.TargetRevision = "HEAD"
        }</span>

        <span class="cov0" title="0">reqBody, err := json.Marshal(app)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal application: %w", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("http://%s/api/v1/applications", a.ServerAddress)
        req, err := http.NewRequestWithContext(context.Background(), "POST", url, bytes.NewBuffer(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create application request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+a.authToken)

        resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create application: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debugln("Failed to close response body: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to create application: HTTP %d - %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *ArgoInstaller) deleteApplication(options *InstallOptions) error <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("http://%s/api/v1/applications/%s", a.ServerAddress, options.ApplicationName)
        req, err := http.NewRequestWithContext(context.Background(), "DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create delete request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+a.authToken)

        q := req.URL.Query()
        q.Add("cascade", "true")
        req.URL.RawQuery = q.Encode()

        resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete application: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debugln("Failed to close response body: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusNoContent &amp;&amp;
                resp.StatusCode != http.StatusNotFound </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to delete application: HTTP %d - %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *ArgoInstaller) setupPortForward() error <span class="cov0" title="0">{
        podList, err := a.k8sClient.Clientset.CoreV1().Pods(a.ArgoNamespace).List(context.Background(), metav1.ListOptions{
                LabelSelector: labels.Set{"app.kubernetes.io/name": "argocd-server"}.String(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list ArgoCD server pods: %w", err)
        }</span>

        <span class="cov0" title="0">if len(podList.Items) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no ArgoCD server pods found in namespace %s", a.ArgoNamespace)
        }</span>

        <span class="cov0" title="0">pod := podList.Items[0]
        if pod.Status.Phase != corev1.PodRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("ArgoCD server pod is not running: %s", pod.Status.Phase)
        }</span>

        <span class="cov0" title="0">logger.Infoln("Setting up port forward to ArgoCD server pod: %s", pod.Name)
        req := a.k8sClient.Clientset.CoreV1().RESTClient().Post().
                Resource("pods").
                Namespace(a.ArgoNamespace).
                Name(pod.Name).
                SubResource("portforward")
        transport, upgrader, err := spdy.RoundTripperFor(a.k8sClient.Config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SPDY transport: %w", err)
        }</span>
        <span class="cov0" title="0">ports := []string{fmt.Sprintf("%d:8080", a.LocalPort)}

        a.stopChannel = make(chan struct{}, 1)
        a.readyChannel = make(chan struct{}, 1)
        out := &amp;bytes.Buffer{}
        errOut := &amp;bytes.Buffer{}
        dialer := spdy.NewDialer(upgrader, &amp;http.Client{Transport: transport}, "POST", req.URL())
        forwarder, err := portforward.New(
                dialer,
                ports,
                a.stopChannel,
                a.readyChannel,
                out,
                errOut,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create port forwarder: %w", err)
        }</span>

        <span class="cov0" title="0">errChan := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                if err := forwarder.ForwardPorts(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Port forwarding failed: %v", err)
                        errChan &lt;- err
                }</span>
        }()

        <span class="cov0" title="0">select </span>{
        case &lt;-a.readyChannel:<span class="cov0" title="0">
                logger.Infoln("Port forward established successfully")</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                close(a.stopChannel)
                return fmt.Errorf("port forwarding failed: %w", err)</span>
        case &lt;-time.After(15 * time.Second):<span class="cov0" title="0">
                close(a.stopChannel)
                return fmt.Errorf("timeout waiting for port forward to be ready")</span>
        }

        <span class="cov0" title="0">a.ServerAddress = fmt.Sprintf("localhost:%d", a.LocalPort)
        return nil</span>
}

func (a *ArgoInstaller) GetAdminPassword() (string, error) <span class="cov0" title="0">{
        secret, err := a.k8sClient.Clientset.CoreV1().Secrets(a.ArgoNamespace).Get(
                context.Background(), "argocd-initial-admin-secret", metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get ArgoCD admin secret: %w", err)
        }</span>

        <span class="cov0" title="0">password := string(secret.Data["password"])
        if password == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ArgoCD admin password not found in secret")
        }</span>

        <span class="cov0" title="0">return password, nil</span>
}

func (a *ArgoInstaller) ValidateArgoConnection() error <span class="cov8" title="1">{
        if a.ServerAddress == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no active connection to ArgoCD")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (a *ArgoInstaller) cleanup() <span class="cov8" title="1">{
        a.authToken = ""
        a.ServerAddress = ""
        if a.stopChannel != nil </span><span class="cov0" title="0">{
                logger.Infoln("Terminating port forward process...")
                close(a.stopChannel)
                a.stopChannel = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package installer

import (
        "context"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "time"

        "helm.sh/helm/v3/pkg/action"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/chart/loader"
        "helm.sh/helm/v3/pkg/cli"
        "helm.sh/helm/v3/pkg/getter"
        "helm.sh/helm/v3/pkg/repo"
)

var settings = cli.New()

func NewHelmInstaller(kubeConfig string) (*HelmInstaller, error) <span class="cov0" title="0">{
        return &amp;HelmInstaller{
                KubeConfig: kubeConfig,
        }, nil
}</span>

type HelmInstaller struct {
        KubeConfig string
}

func (h *HelmInstaller) Install(options *InstallOptions) error <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()
        actionConfig, err := h.createHelmActionConfig(options.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create helm action config: %w", err)
        }</span>

        <span class="cov0" title="0">histClient := action.NewHistory(actionConfig)
        histClient.Max = 1
        _, err = histClient.Run(options.ApplicationName)

        if err == nil </span><span class="cov0" title="0">{
                // Release exists, upgrade it
                upgrade := action.NewUpgrade(actionConfig)
                upgrade.Namespace = options.Namespace

                chart, err := h.downloadAndLoadChart(options)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to download and load chart: %w", err)
                }</span>

                <span class="cov0" title="0">rel, err := upgrade.RunWithContext(ctx, options.ApplicationName, chart, options.Values)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error upgrading chart: %v\n", err)
                        return fmt.Errorf("failed to upgrade chart: %w", err)
                }</span>

                <span class="cov0" title="0">if rel == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get release information")
                }</span>
        } else<span class="cov0" title="0"> {
                // Release doesn't exist, install it
                install := action.NewInstall(actionConfig)
                install.Namespace = options.Namespace
                install.ReleaseName = options.ApplicationName
                install.CreateNamespace = true

                chart, err := h.downloadAndLoadChart(options)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to download and load chart: %w", err)
                }</span>

                <span class="cov0" title="0">rel, err := install.RunWithContext(ctx, chart, options.Values)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error installing chart: %v\n", err)
                        return fmt.Errorf("failed to install chart: %w", err)
                }</span>

                <span class="cov0" title="0">if rel == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get release information")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (h *HelmInstaller) UnInstall(options *InstallOptions) error <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">actionConfig, err := h.createHelmActionConfig(options.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create helm action config: %w", err)
        }</span>

        <span class="cov0" title="0">uninstall := action.NewUninstall(actionConfig)
        uninstall.Timeout = 5 * time.Minute
        uninstall.Wait = true

        _, err = uninstall.Run(options.ApplicationName)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error uninstalling chart: %v\n", err)
                return fmt.Errorf("failed to uninstall chart: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *HelmInstaller) createHelmActionConfig(namespace string) (*action.Configuration, error) <span class="cov0" title="0">{
        tmpPath := filepath.Join(os.TempDir(), fmt.Sprintf("kubeconfig-%d", time.Now().UnixNano()))

        if err := os.WriteFile(tmpPath, []byte(h.KubeConfig), 0o600); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write kubeconfig to temp file: %w", err)
        }</span>

        <span class="cov0" title="0">settings.KubeConfig = tmpPath
        actionConfig := new(action.Configuration)
        if err := actionConfig.Init(settings.RESTClientGetter(), namespace, os.Getenv("HELM_DRIVER"), log.Printf); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize helm action config: %w", err)
        }</span>

        <span class="cov0" title="0">return actionConfig, nil</span>
}

func (h *HelmInstaller) downloadAndLoadChart(options *InstallOptions) (*chart.Chart, error) <span class="cov0" title="0">{
        chartPathOptions := action.ChartPathOptions{
                RepoURL:            options.RepoURL,
                Version:            options.Version,
                PassCredentialsAll: true,
        }

        if err := h.addHelmRepo(options); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add helm repository: %w", err)
        }</span>

        <span class="cov0" title="0">chartPath, err := chartPathOptions.LocateChart(*options.ChartName, settings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to locate chart %s: %w", *options.ChartName, err)
        }</span>

        <span class="cov0" title="0">log.Printf("Chart found at: %s\n", chartPath)

        loadedChart, err := loader.Load(chartPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load chart from %s: %w", chartPath, err)
        }</span>

        <span class="cov0" title="0">if loadedChart.Metadata.Name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("chart has no name")
        }</span>

        <span class="cov0" title="0">if loadedChart.Metadata.Version == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("chart has no version")
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully loaded chart: %s version %s\n", loadedChart.Metadata.Name, loadedChart.Metadata.Version)

        return loadedChart, nil</span>
}

func (h *HelmInstaller) addHelmRepo(options *InstallOptions) error <span class="cov0" title="0">{
        entry := repo.Entry{
                Name: options.RepoName,
                URL:  options.RepoURL,
        }

        r, err := repo.NewChartRepository(&amp;entry, getter.All(settings))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create chart repository: %w", err)
        }</span>

        <span class="cov0" title="0">indexFilePath, err := r.DownloadIndexFile()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download repository index: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = repo.LoadIndexFile(indexFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load repository index: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package k8s

import (
        "context"

        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
)

type K8sClient struct {
        Clientset *kubernetes.Clientset
        Dynamic   *dynamic.DynamicClient
        Config    *rest.Config
}

func NewK8sClient(kubeConfig string) (*K8sClient, error) <span class="cov0" title="0">{
        restConfig, err := clientcmd.RESTConfigFromKubeConfig([]byte(kubeConfig))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">clientset, err := kubernetes.NewForConfig(restConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dynamicClient, err := dynamic.NewForConfig(restConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;K8sClient{
                Clientset: clientset,
                Dynamic:   dynamicClient,
                Config:    restConfig,
        }, nil</span>
}

func (k *K8sClient) GetNameSpace(name string, ctx context.Context) (string, error) <span class="cov0" title="0">{
        namespace, err := k.Clientset.CoreV1().Namespaces().Get(ctx, name, v1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return namespace.Name, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package multipass

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "strings"
        "sync"
        "time"

        "github.com/mrgb7/playground/pkg/logger"
)

type Client interface {
        IsMultipassInstalled() bool
        CreateCluster(clusterName string, nodeCount int, masterCPUs int, masterMemory, masterDisk string,
                workerCPUs int, workerMemory, workerDisk string, wg *sync.WaitGroup) error
        DeleteCluster(clusterName string, wg *sync.WaitGroup) error
        ListClusters() ([]string, error)
        CreateNode(name string, cpus int, memory string, disk string) error
        DeleteNode(name string) error
        PurgeNodes() error
        GetNodeIP(name string) (string, error)
        ExecuteShell(name string, command string) (string, error)
        ExecuteShellWithTimeout(name string, command string, timeoutSeconds int, envs ...string) (string, error)
}

type MultiPassList struct {
        List []MultiPassListItem `json:"list"`
}

type MultiPassListItem struct {
        Name string `json:"name"`
}

type MultiPassInfo struct {
        Errors []interface{}            `json:"errors"`
        Info   map[string]MultiPassNode `json:"info"`
}

type MultiPassNode struct {
        IPv4 []string `json:"ipv4"`
}

type MultipassClient struct {
        BinaryPath string
}

const (
        DefaultMasterCPUs   = 2
        DefaultMasterMemory = "2G"
        DefaultMasterDisk   = "10G"
        DefaultWorkerCPUs   = 1
        DefaultWorkerMemory = "1G"
        DefaultWorkerDisk   = "5G"
)

func NewMultipassClient() *MultipassClient <span class="cov8" title="1">{
        return &amp;MultipassClient{
                BinaryPath: "multipass",
        }
}</span>

func (m *MultipassClient) IsMultipassInstalled() bool <span class="cov8" title="1">{
        cmd := exec.Command(m.BinaryPath, "--version") //nolint:gosec
        err := cmd.Run()
        return err == nil
}</span>

func (m *MultipassClient) CreateCluster(
        clusterName string, nodeCount int, masterCPUs int, masterMemory, masterDisk string,
        workerCPUs int, workerMemory, workerDisk string, wg *sync.WaitGroup,
) error <span class="cov0" title="0">{
        masterName := fmt.Sprintf("%s-master", clusterName)
        errChan := make(chan error, nodeCount)

        wg.Add(1)
        go func(name string) </span><span class="cov0" title="0">{
                defer wg.Done()
                err := m.CreateNode(name, masterCPUs, masterMemory, masterDisk)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("failed to create master node %s: %v\n", name, err)
                        errChan &lt;- fmt.Errorf("failed to create master node %s: %w", name, err)
                        return
                }</span>
                <span class="cov0" title="0">logger.Debugln("Master node %s created successfully", name)</span>
        }(masterName)

        <span class="cov0" title="0">for i := 1; i &lt; nodeCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(workerIndex int) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        nodeName := fmt.Sprintf("%s-worker-%d", clusterName, workerIndex)
                        err := m.CreateNode(nodeName, workerCPUs, workerMemory, workerDisk)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("failed to create worker node %s: %v", nodeName, err)
                                errChan &lt;- fmt.Errorf("failed to create worker node %s: %w", nodeName, err)
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debugln("Worker node %s created successfully", nodeName)</span>
                }(i)
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(errChan)
        }</span>()

        <span class="cov0" title="0">var creationErrors []error
        for err := range errChan </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        creationErrors = append(creationErrors, err)
                }</span>
        }

        <span class="cov0" title="0">if len(creationErrors) &gt; 0 </span><span class="cov0" title="0">{
                logger.Errorln("Error during cluster creation for '%s', attempting cleanup.", clusterName)

                var cleanupWG sync.WaitGroup
                if cleanupErr := m.DeleteCluster(clusterName, &amp;cleanupWG); cleanupErr != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Failed to cleanup cluster %s during error recovery: %v", clusterName, cleanupErr)
                }</span>

                <span class="cov0" title="0">return creationErrors[0]</span>
        }

        <span class="cov0" title="0">logger.Debugln("Cluster %s created successfully with %d total instances.", clusterName, nodeCount)
        return nil</span>
}

func (m *MultipassClient) DeleteCluster(clusterName string, wg *sync.WaitGroup) error <span class="cov0" title="0">{
        var list MultiPassList
        cmd := exec.Command(m.BinaryPath, "list", "--format", "json") //nolint:gosec
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list instances: %s - %w", stderr.String(), err)
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(stdout.Bytes(), &amp;list); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse JSON output: %w", err)
        }</span>

        <span class="cov0" title="0">var instancesToDelete []string
        for _, instance := range list.List </span><span class="cov0" title="0">{
                if strings.HasPrefix(instance.Name, clusterName) </span><span class="cov0" title="0">{
                        instancesToDelete = append(instancesToDelete, instance.Name)
                }</span>
        }

        <span class="cov0" title="0">errChan := make(chan error, len(instancesToDelete))

        for _, instanceName := range instancesToDelete </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(name string) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if err := m.DeleteNode(name); err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- fmt.Errorf("failed to delete node %s: %w", name, err)
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debugf("Successfully deleted node: %s", name)</span>
                }(instanceName)
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(errChan)
        }</span>()

        <span class="cov0" title="0">var errors []error
        for err := range errChan </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, err)
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                var errMessages []string
                for _, err := range errors </span><span class="cov0" title="0">{
                        errMessages = append(errMessages, err.Error())
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("multiple deletion errors: %s", strings.Join(errMessages, "; "))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (m *MultipassClient) CreateNode(name string, cpus int, memory string, disk string) error <span class="cov8" title="1">{
        args := []string{
                "launch",
                "--name", name,
                "--cpus", fmt.Sprintf("%d", cpus),
                "--memory", memory,
                "--disk", disk,
        }

        logger.Debugln("Creating node: %s with %d CPUs, %s memory, %s disk", name, cpus, memory, disk)
        cmd := exec.Command(m.BinaryPath, args...) //nolint:gosec
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create node '%s': %s - %w", name, stderr.String(), err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *MultipassClient) DeleteNode(name string) error <span class="cov0" title="0">{
        cmd := exec.Command(m.BinaryPath, "delete", name) //nolint:gosec
        var stderr bytes.Buffer
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete node '%s': %s - %w", name, stderr.String(), err)
        }</span>

        <span class="cov0" title="0">logger.Debugln("Successfully deleted node '%s'", name)
        return nil</span>
}

func (m *MultipassClient) PurgeNodes() error <span class="cov0" title="0">{
        logger.Infoln("Purging deleted nodes")
        // Binary path is controlled, this is a legitimate multipass CLI call
        cmd := exec.Command(m.BinaryPath, "purge") //nolint:gosec
        var stderr bytes.Buffer
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to purge deleted instances: %s - %w", stderr.String(), err)
        }</span>

        <span class="cov0" title="0">logger.Successln("Successfully purged deleted nodes")
        return nil</span>
}

func (m *MultipassClient) GetNodeIP(name string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command(m.BinaryPath, "info", name, "--format", "json") //nolint:gosec
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get IP address for node '%s': %s - %w", name, stderr.String(), err)
        }</span>

        <span class="cov0" title="0">var data MultiPassInfo
        if err := json.Unmarshal(stdout.Bytes(), &amp;data); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse JSON output: %w", err)
        }</span>

        <span class="cov0" title="0">nodeInfo, exists := data.Info[name]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("node '%s' not found in multipass info", name)
        }</span>

        <span class="cov0" title="0">if len(nodeInfo.IPv4) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no IPv4 addresses found for node '%s'", name)
        }</span>

        <span class="cov0" title="0">ip := nodeInfo.IPv4[0]
        return ip, nil</span>
}

func (m *MultipassClient) ExecuteShell(name string, command string) (string, error) <span class="cov0" title="0">{
        return m.ExecuteShellWithTimeout(name, command, 0) // No timeout by default
}</span>

func (m *MultipassClient) ExecuteShellWithTimeout(name string, command string, timeoutSeconds int,
        envs ...string,
) (string, error) <span class="cov0" title="0">{
        ctx := context.Background()
        var cancel context.CancelFunc

        if timeoutSeconds &gt; 0 </span><span class="cov0" title="0">{
                ctx, cancel = context.WithTimeout(context.Background(), time.Duration(timeoutSeconds)*time.Second)
                defer cancel()
        }</span>

        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, m.BinaryPath, "exec", name, "--", "bash", "-c", command) //nolint:gosec
        cmd.Env = append(os.Environ(), envs...)
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Failed to execute command on node '%s': %v", name, err)
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        return stdout.String(), fmt.Errorf("command timed out after %d seconds", timeoutSeconds)
                }</span>

                <span class="cov0" title="0">errMsg := fmt.Sprintf("Failed to execute shell command on node '%s': %s", name, stderr.String())
                logger.Errorln(errMsg)
                return "", fmt.Errorf("failed to execute shell command on node '%s': %s - %w", name, stderr.String(), err)</span>
        }

        <span class="cov0" title="0">return stdout.String(), nil</span>
}

func (m *MultipassClient) ListClusters() ([]string, error) <span class="cov0" title="0">{
        var list MultiPassList
        cmd := exec.Command(m.BinaryPath, "list", "--format", "json") //nolint:gosec
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list instances: %s - %w", stderr.String(), err)
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(stdout.Bytes(), &amp;list); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse JSON output: %w", err)
        }</span>

        <span class="cov0" title="0">var clusters []string
        seenClusters := make(map[string]bool) // To avoid duplicates

        for _, instance := range list.List </span><span class="cov0" title="0">{
                if strings.HasSuffix(instance.Name, "-master") </span><span class="cov0" title="0">{
                        clusterName := strings.TrimSuffix(instance.Name, "-master")
                        if !seenClusters[clusterName] </span><span class="cov0" title="0">{
                                clusters = append(clusters, clusterName)
                                seenClusters[clusterName] = true
                        }</span>
                }
        }

        <span class="cov0" title="0">return clusters, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package plugins

import (
        "context"
        "crypto/sha256"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"

        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
        "gopkg.in/yaml.v3"
)

type Argocd struct {
        KubeConfig string
        *BasePlugin
}

const (
        ArgocdRepoURL       = "https://argoproj.github.io/argo-helm"
        ArgocdChartName     = "argo-cd"
        ArgocdChartVersion  = "8.0.0"
        ArgocdReleaseName   = "argocd"
        ArgocdNamespace     = "argocd"
        ArgoRepoName        = "argo"
        ArgocdValuesFileURL = "https://raw.githubusercontent.com/mrgb7/core-infrastructure/" +
                "refs/heads/main/argocd/argocd-values-local.yaml"

        HTTPTimeoutSeconds = 30
        MaxResponseSize    = 10 * 1024 * 1024
)

func NewArgocd(kubeConfig string) *Argocd <span class="cov8" title="1">{
        argo := &amp;Argocd{
                KubeConfig: kubeConfig,
        }
        argo.BasePlugin = NewBasePlugin(kubeConfig, argo)
        return argo
}</span>

func (a *Argocd) GetName() string <span class="cov0" title="0">{
        return "argocd"
}</span>

func (a *Argocd) Install(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return a.UnifiedInstall(kubeConfig, clusterName, ensure...)
}</span>

func (a *Argocd) Uninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return a.UnifiedUninstall(kubeConfig, clusterName, ensure...)
}</span>

func (a *Argocd) getValuesContent() (map[string]interface{}, error) <span class="cov0" title="0">{
        if _, err := url.Parse(ArgocdValuesFileURL); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid values file URL: %w", err)
        }</span>

        <span class="cov0" title="0">httpClient := &amp;http.Client{
                Timeout: HTTPTimeoutSeconds * time.Second,
        }

        ctx, cancel := context.WithTimeout(context.Background(), HTTPTimeoutSeconds*time.Second)
        defer cancel()

        req, err := http.NewRequestWithContext(ctx, "GET", ArgocdValuesFileURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch values file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debugln("Failed to close response body: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch values file: HTTP %d %s", resp.StatusCode, resp.Status)
        }</span>

        <span class="cov0" title="0">limitedReader := io.LimitReader(resp.Body, MaxResponseSize)
        content, err := io.ReadAll(limitedReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov0" title="0">hash := sha256.Sum256(content)
        logger.Debugf("ArgoCD values file SHA256: %x", hash)

        var values map[string]interface{}
        if err := yaml.Unmarshal(content, &amp;values); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal YAML content: %w", err)
        }</span>

        <span class="cov0" title="0">return values, nil</span>
}

func (a *Argocd) Status() string <span class="cov0" title="0">{
        c, err := k8s.NewK8sClient(a.KubeConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to create k8s client: %v", err)
                return StatusUnknown
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        ns, err := c.GetNameSpace(ArgocdNamespace, ctx)
        if ns == "" || err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to get argocd namespace: %v", err)
                return StatusNotInstalled
        }</span>
        <span class="cov0" title="0">return "argocd is running"</span>
}

func (a *Argocd) GetNamespace() string <span class="cov0" title="0">{
        return ArgocdNamespace
}</span>

func (a *Argocd) GetVersion() string <span class="cov0" title="0">{
        return ArgocdChartVersion
}</span>

func (a *Argocd) GetChartName() string <span class="cov0" title="0">{
        return ArgocdChartName
}</span>

func (a *Argocd) GetRepository() string <span class="cov0" title="0">{
        return ArgocdRepoURL
}</span>

func (a *Argocd) GetChartValues() map[string]interface{} <span class="cov0" title="0">{
        val, err := a.getValuesContent()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to get values content: %v", err)
                return nil
        }</span>
        <span class="cov0" title="0">return val</span>
}

func (a *Argocd) GetRepoName() string <span class="cov0" title="0">{
        return ArgoRepoName
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package plugins

import (
        "fmt"

        "github.com/mrgb7/playground/internal/installer"
)

const (
        StatusNotInstalled = "Not installed"
        StatusUnknown      = "UNKNOWN"
        StatusRunning      = "running"
)

type BasePlugin struct {
        KubeConfig string
        plugin     Plugin
}

func NewBasePlugin(kubeConfig string, plugin Plugin) *BasePlugin <span class="cov8" title="1">{
        return &amp;BasePlugin{
                KubeConfig: kubeConfig,
                plugin:     plugin,
        }
}</span>

func (b *BasePlugin) UnifiedInstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        inst, err := NewInstaller(b.plugin, kubeConfig, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create installer: %w", err)
        }</span>

        <span class="cov0" title="0">opts := newInstallOptions(b.plugin, kubeConfig)

        return inst.Install(opts)</span>
}

func (b *BasePlugin) UnifiedUninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        inst, err := NewInstaller(b.plugin, kubeConfig, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create installer: %w", err)
        }</span>
        <span class="cov0" title="0">opts := newInstallOptions(b.plugin, kubeConfig)
        return inst.UnInstall(opts)</span>
}

func newInstallOptions(plugin Plugin, kubeConfig string) *installer.InstallOptions <span class="cov0" title="0">{
        chartName := plugin.GetChartName()
        version := plugin.GetVersion()
        return &amp;installer.InstallOptions{
                Namespace:       plugin.GetNamespace(),
                Values:          plugin.GetChartValues(),
                ChartName:       &amp;chartName,
                RepoURL:         plugin.GetRepository(),
                ApplicationName: plugin.GetName(),
                Version:         version,
                KubeConfig:      kubeConfig,
                RepoName:        plugin.GetRepoName(),
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package plugins

import (
        "context"
        "time"

        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
)

type CertManager struct {
        KubeConfig string
        *BasePlugin
}

const (
        CertManagerRepoURL      = "https://charts.jetstack.io"
        CertManagerChartName    = "cert-manager"
        CertManagerChartVersion = "v1.17.2"
        CertManagerReleaseName  = "cert-manager"
        CertManagerNamespace    = "cert-manager"
        CertManagerRepoName     = "jetstack"

        DefaultWebhookTimeout = 10
)

func NewCertManager(kubeConfig string) *CertManager <span class="cov8" title="1">{
        cm := &amp;CertManager{
                KubeConfig: kubeConfig,
        }
        cm.BasePlugin = NewBasePlugin(kubeConfig, cm)
        return cm
}</span>

func (c *CertManager) GetName() string <span class="cov0" title="0">{
        return "cert-manager"
}</span>

func (c *CertManager) Install(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return c.UnifiedInstall(kubeConfig, clusterName, ensure...)
}</span>

func (c *CertManager) Uninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return c.UnifiedUninstall(kubeConfig, clusterName, ensure...)
}</span>

func (c *CertManager) getDefaultValues() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "crds": map[string]interface{}{
                        "enabled": true,
                },
                "prometheus": map[string]interface{}{
                        "enabled": true,
                },
                "webhook": map[string]interface{}{
                        "timeoutSeconds": DefaultWebhookTimeout,
                },
        }
}</span>

func (c *CertManager) Status() string <span class="cov0" title="0">{
        client, err := k8s.NewK8sClient(c.KubeConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to create k8s client: %v", err)
                return StatusUnknown
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        ns, err := client.GetNameSpace(CertManagerNamespace, ctx)
        if ns == "" || err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to get cert-manager namespace: %v", err)
                return StatusNotInstalled
        }</span>
        <span class="cov0" title="0">return "cert-manager is running"</span>
}

func (c *CertManager) GetNamespace() string <span class="cov0" title="0">{
        return CertManagerNamespace
}</span>

func (c *CertManager) GetVersion() string <span class="cov0" title="0">{
        return CertManagerChartVersion
}</span>

func (c *CertManager) GetChartName() string <span class="cov0" title="0">{
        return CertManagerChartName
}</span>

func (c *CertManager) GetRepository() string <span class="cov0" title="0">{
        return CertManagerRepoURL
}</span>

func (c *CertManager) GetChartValues() map[string]interface{} <span class="cov0" title="0">{
        return c.getDefaultValues()
}</span>

func (c *CertManager) GetReleaseName() string <span class="cov0" title="0">{
        return CertManagerReleaseName
}</span>

func (c *CertManager) GetRepoName() string <span class="cov0" title="0">{
        return CertManagerRepoName
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package plugins

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
        v1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

const (
        IngressNamespace = "ingress-system"
        IngressName      = "ingress"
        IngressVersion   = "1.0.0"
        ArgoCDPort       = 80
        TrueValue        = "true"
        FalseValue       = "false"
)

type Ingress struct {
        KubeConfig  string
        k8sClient   *k8s.K8sClient
        ClusterName string
        *BasePlugin
}

func NewIngress(kubeConfig, clusterName string) (*Ingress, error) <span class="cov8" title="1">{
        c, err := k8s.NewK8sClient(kubeConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create k8s client: %w", err)
        }</span>
        <span class="cov0" title="0">ingress := &amp;Ingress{
                KubeConfig:  kubeConfig,
                k8sClient:   c,
                ClusterName: clusterName,
        }
        ingress.BasePlugin = NewBasePlugin(kubeConfig, ingress)
        return ingress, nil</span>
}

func (i *Ingress) GetName() string <span class="cov0" title="0">{
        return IngressName
}</span>

func (i *Ingress) Install(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        logger.Infoln("Installing ingress plugin for cluster: %s", clusterName)

        if err := i.checkDependencies(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dependency check failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := i.ensureNginxLoadBalancer(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure nginx LoadBalancer: %w", err)
        }</span>

        <span class="cov0" title="0">i.setupClusterDomain()

        if err := i.configureArgoCDIngress(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure ArgoCD ingress: %w", err)
        }</span>

        <span class="cov0" title="0">if err := i.printHostInstructions(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to print host instructions: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Successln("Ingress plugin installed successfully")
        return nil</span>
}

func (i *Ingress) Uninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        logger.Infoln("Uninstalling ingress plugin")

        err := i.removeArgoCDIngress()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnln("Failed to remove ArgoCD ingress: %v", err)
        }</span>

        <span class="cov0" title="0">logger.Successln("Ingress plugin uninstalled successfully")
        return nil</span>
}

func (i *Ingress) Status() string <span class="cov0" title="0">{
        nginx := NewNginx(i.KubeConfig)
        lb, _ := NewLoadBalancer(i.KubeConfig, "")

        nginxStatus := nginx.Status()
        lbStatus := lb.Status()

        if !strings.Contains(nginxStatus, StatusRunning) || !strings.Contains(lbStatus, StatusRunning) </span><span class="cov0" title="0">{
                return "Ingress dependencies not satisfied"
        }</span>

        <span class="cov0" title="0">return "Ingress is configured"</span>
}

func (i *Ingress) checkDependencies() error <span class="cov0" title="0">{
        logger.Infoln("Checking ingress dependencies...")

        nginx := NewNginx(i.KubeConfig)
        nginxStatus := nginx.Status()
        if !strings.Contains(nginxStatus, StatusRunning) </span><span class="cov0" title="0">{
                return fmt.Errorf("nginx plugin is required but not installed/running. Status: %s", nginxStatus)
        }</span>

        <span class="cov0" title="0">lb, err := NewLoadBalancer(i.KubeConfig, "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create loadbalancer client: %w", err)
        }</span>
        <span class="cov0" title="0">lbStatus := lb.Status()
        if !strings.Contains(lbStatus, StatusRunning) </span><span class="cov0" title="0">{
                return fmt.Errorf("loadbalancer plugin is required but not installed/running. Status: %s", lbStatus)
        }</span>

        <span class="cov0" title="0">logger.Successln("All dependencies satisfied")
        return nil</span>
}

func (i *Ingress) ensureNginxLoadBalancer() error <span class="cov0" title="0">{
        logger.Infoln("Ensuring nginx service is LoadBalancer type...")

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        svc, err := i.k8sClient.Clientset.CoreV1().Services(NginxNamespace).Get(
                ctx, "nginx-ingress-ingress-nginx-controller", metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get nginx service: %w", err)
        }</span>

        <span class="cov0" title="0">if svc.Spec.Type == v1.ServiceTypeLoadBalancer </span><span class="cov0" title="0">{
                logger.Debugln("Nginx service is already LoadBalancer type")
                return nil
        }</span>

        <span class="cov0" title="0">svc.Spec.Type = v1.ServiceTypeLoadBalancer
        _, err = i.k8sClient.Clientset.CoreV1().Services(NginxNamespace).Update(ctx, svc, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update nginx service to LoadBalancer: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Successln("Updated nginx service to LoadBalancer type")
        return nil</span>
}

func (i *Ingress) setupClusterDomain() <span class="cov0" title="0">{
        logger.Infoln("Setting up cluster domain: %s.local", i.ClusterName)
}</span>

func (i *Ingress) configureArgoCDIngress() error <span class="cov0" title="0">{
        logger.Infoln("Checking for ArgoCD installation...")

        argocd := NewArgocd(i.KubeConfig)
        argoCDStatus := argocd.Status()
        if !strings.Contains(argoCDStatus, StatusRunning) </span><span class="cov0" title="0">{
                logger.Infoln("ArgoCD not installed, skipping ingress configuration")
                return nil
        }</span>

        <span class="cov0" title="0">logger.Infoln("ArgoCD found, configuring ingress...")

        isTLSAvailable := i.isTLSClusterIssuerAvailable()
        if isTLSAvailable </span><span class="cov0" title="0">{
                logger.Infoln("TLS cluster issuer found, enabling HTTPS for ArgoCD")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        existingIngress, err := i.k8sClient.Clientset.NetworkingV1().Ingresses("argocd").Get(
                ctx, "argocd-server", metav1.GetOptions{})
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check existing ArgoCD ingress: %w", err)
        }</span>

        <span class="cov0" title="0">hostname := fmt.Sprintf("argocd.%s.local", i.ClusterName)

        if err == nil </span><span class="cov0" title="0">{
                return i.updateExistingArgoCDIngress(existingIngress, hostname, isTLSAvailable)
        }</span>
        <span class="cov0" title="0">return i.createNewArgoCDIngress(hostname, isTLSAvailable)</span>
}

func (i *Ingress) removeArgoCDIngress() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        err := i.k8sClient.Clientset.NetworkingV1().Ingresses("argocd").Delete(
                ctx, "argocd-server", metav1.DeleteOptions{})
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete ArgoCD ingress: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (i *Ingress) printHostInstructions() error <span class="cov0" title="0">{
        logger.Infoln("Getting nginx LoadBalancer IP...")

        ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
        defer cancel()

        var nginxIP string
        for retries := 0; retries &lt; 12; retries++ </span><span class="cov0" title="0">{
                svc, err := i.k8sClient.Clientset.CoreV1().Services(NginxNamespace).Get(
                        ctx, "nginx-ingress-ingress-nginx-controller", metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get nginx service: %w", err)
                }</span>

                <span class="cov0" title="0">if len(svc.Status.LoadBalancer.Ingress) &gt; 0 </span><span class="cov0" title="0">{
                        if svc.Status.LoadBalancer.Ingress[0].IP != "" </span><span class="cov0" title="0">{
                                nginxIP = svc.Status.LoadBalancer.Ingress[0].IP
                                break</span>
                        }
                }

                <span class="cov0" title="0">logger.Infoln("Waiting for LoadBalancer IP assignment... (%d/12)", retries+1)
                time.Sleep(5 * time.Second)</span>
        }

        <span class="cov0" title="0">if nginxIP == "" </span><span class="cov0" title="0">{
                logger.Warnln("LoadBalancer IP not available yet. You can run this command later to get it:")
                logger.Infoln("kubectl get svc -n %s nginx-ingress-ingress-nginx-controller "+
                        "-o jsonpath='{.status.loadBalancer.ingress[0].ip}'", NginxNamespace)
                return nil
        }</span>

        <span class="cov0" title="0">logger.Successln("LoadBalancer IP found: %s", nginxIP)
        logger.Infoln("")
        logger.Infoln("🎯 Add these entries to your /etc/hosts file:")
        logger.Infoln("echo '%s %s.local' | sudo tee -a /etc/hosts", nginxIP, i.ClusterName)

        argocd := NewArgocd(i.KubeConfig)
        argoCDStatus := argocd.Status()
        if strings.Contains(argoCDStatus, StatusRunning) </span><span class="cov0" title="0">{
                logger.Infoln("echo '%s argocd.%s.local' | sudo tee -a /etc/hosts", nginxIP, i.ClusterName)
                logger.Infoln("")

                isTLSAvailable := i.isTLSClusterIssuerAvailable()
                if isTLSAvailable </span><span class="cov0" title="0">{
                        logger.Infoln("🚀 ArgoCD will be available at: https://argocd.%s.local", i.ClusterName)
                        logger.Infoln("🔒 TLS certificates will be automatically generated")
                }</span> else<span class="cov0" title="0"> {
                        logger.Infoln("🚀 ArgoCD will be available at: http://argocd.%s.local", i.ClusterName)
                        logger.Infoln("💡 Install TLS plugin for HTTPS support:")
                        logger.Infoln("   playground cluster plugin add --name tls --cluster %s", i.ClusterName)
                }</span>
        }

        <span class="cov0" title="0">logger.Infoln("")
        logger.Infoln("🌐 Cluster domain: %s.local", i.ClusterName)

        return nil</span>
}

func (i *Ingress) GetNamespace() string <span class="cov0" title="0">{
        return IngressNamespace
}</span>

func (i *Ingress) GetVersion() string <span class="cov0" title="0">{
        return IngressVersion
}</span>

func (i *Ingress) GetChartName() string <span class="cov0" title="0">{
        return ""
}</span>

func (i *Ingress) GetRepository() string <span class="cov0" title="0">{
        return ""
}</span>

func (i *Ingress) GetRepoName() string <span class="cov0" title="0">{
        return ""
}</span>

func (i *Ingress) GetChartValues() map[string]interface{} <span class="cov0" title="0">{
        return make(map[string]interface{})
}</span>

func (i *Ingress) isTLSClusterIssuerAvailable() bool <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        gvr := schema.GroupVersionResource{
                Group:    "cert-manager.io",
                Version:  "v1",
                Resource: "clusterissuers",
        }

        tls := &amp;TLS{}
        issuerName := tls.GetClusterIssuerName()
        _, err := i.k8sClient.Dynamic.Resource(gvr).Get(ctx, issuerName, metav1.GetOptions{})
        return err == nil
}</span>

func (i *Ingress) updateExistingArgoCDIngress(
        existingIngress *networkingv1.Ingress,
        hostname string,
        isTLSAvailable bool,
) error <span class="cov0" title="0">{
        logger.Infoln("Updating existing ArgoCD ingress with cluster domain and TLS...")

        if len(existingIngress.Spec.Rules) &gt; 0 </span><span class="cov0" title="0">{
                existingIngress.Spec.Rules[0].Host = hostname
        }</span>

        <span class="cov0" title="0">if isTLSAvailable </span><span class="cov0" title="0">{
                if existingIngress.Annotations == nil </span><span class="cov0" title="0">{
                        existingIngress.Annotations = make(map[string]string)
                }</span>
                <span class="cov0" title="0">tls := &amp;TLS{}
                existingIngress.Annotations["cert-manager.io/cluster-issuer"] = tls.GetClusterIssuerName()
                existingIngress.Annotations["nginx.ingress.kubernetes.io/ssl-redirect"] = TrueValue
                existingIngress.Annotations["nginx.ingress.kubernetes.io/force-ssl-redirect"] = TrueValue

                existingIngress.Spec.TLS = []networkingv1.IngressTLS{
                        {
                                Hosts:      []string{hostname},
                                SecretName: "argocd-server-tls",
                        },
                }</span>
        } else<span class="cov0" title="0"> if existingIngress.Annotations != nil </span><span class="cov0" title="0">{
                existingIngress.Annotations["nginx.ingress.kubernetes.io/ssl-redirect"] = FalseValue
                existingIngress.Annotations["nginx.ingress.kubernetes.io/force-ssl-redirect"] = FalseValue
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        _, err := i.k8sClient.Clientset.NetworkingV1().Ingresses("argocd").Update(ctx, existingIngress, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update existing ArgoCD ingress: %w", err)
        }</span>

        <span class="cov0" title="0">if isTLSAvailable </span><span class="cov0" title="0">{
                logger.Successln("Updated existing ArgoCD ingress with HTTPS: https://argocd.%s.local", i.ClusterName)
        }</span> else<span class="cov0" title="0"> {
                logger.Successln("Updated existing ArgoCD ingress with host: argocd.%s.local", i.ClusterName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (i *Ingress) createNewArgoCDIngress(hostname string, isTLSAvailable bool) error <span class="cov0" title="0">{
        logger.Infoln("Creating new ArgoCD ingress...")

        annotations := map[string]string{
                "nginx.ingress.kubernetes.io/backend-protocol": "HTTP",
        }

        var tlsConfig []networkingv1.IngressTLS

        if isTLSAvailable </span><span class="cov0" title="0">{
                tls := &amp;TLS{}
                annotations["cert-manager.io/cluster-issuer"] = tls.GetClusterIssuerName()
                annotations["nginx.ingress.kubernetes.io/ssl-redirect"] = TrueValue
                annotations["nginx.ingress.kubernetes.io/force-ssl-redirect"] = TrueValue
                tlsConfig = []networkingv1.IngressTLS{
                        {
                                Hosts:      []string{hostname},
                                SecretName: "argocd-server-tls",
                        },
                }
        }</span> else<span class="cov0" title="0"> {
                annotations["nginx.ingress.kubernetes.io/ssl-redirect"] = FalseValue
                annotations["nginx.ingress.kubernetes.io/force-ssl-redirect"] = FalseValue
        }</span>

        <span class="cov0" title="0">ingress := &amp;networkingv1.Ingress{
                ObjectMeta: metav1.ObjectMeta{
                        Name:        "argocd-server",
                        Namespace:   "argocd",
                        Annotations: annotations,
                },
                Spec: networkingv1.IngressSpec{
                        IngressClassName: func() *string </span><span class="cov0" title="0">{ s := "nginx"; return &amp;s }</span>(),
                        TLS:              tlsConfig,
                        Rules: []networkingv1.IngressRule{
                                {
                                        Host: hostname,
                                        IngressRuleValue: networkingv1.IngressRuleValue{
                                                HTTP: &amp;networkingv1.HTTPIngressRuleValue{
                                                        Paths: []networkingv1.HTTPIngressPath{
                                                                {
                                                                        Path:     "/",
                                                                        PathType: func() *networkingv1.PathType <span class="cov0" title="0">{ pt := networkingv1.PathTypePrefix; return &amp;pt }</span>(),
                                                                        Backend: networkingv1.IngressBackend{
                                                                                Service: &amp;networkingv1.IngressServiceBackend{
                                                                                        Name: "argocd-server",
                                                                                        Port: networkingv1.ServiceBackendPort{
                                                                                                Number: ArgoCDPort,
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        _, err := i.k8sClient.Clientset.NetworkingV1().Ingresses("argocd").Create(ctx, ingress, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create ArgoCD ingress: %w", err)
        }</span>

        <span class="cov0" title="0">if isTLSAvailable </span><span class="cov0" title="0">{
                logger.Successln("Created ArgoCD ingress with HTTPS: https://argocd.%s.local", i.ClusterName)
        }</span> else<span class="cov0" title="0"> {
                logger.Successln("Created ArgoCD ingress with host: argocd.%s.local", i.ClusterName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package plugins

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

const (
        repoURL      = "https://metallb.github.io/metallb"
        chartName    = "metallb"
        chartVersion = "0.14.9"
        releaseName  = "metallb"
        namespace    = "metallb-system"
        repoName     = "metallb"
)

type LoadBalancer struct {
        KubeConfig      string
        k8sClient       *k8s.K8sClient
        MasterClusterIP string
        *BasePlugin
}

func NewLoadBalancer(kubeConfig string, masterClusterIP string) (*LoadBalancer, error) <span class="cov8" title="1">{
        c, err := k8s.NewK8sClient(kubeConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create k8s client: %w", err)
        }</span>
        <span class="cov0" title="0">lb := &amp;LoadBalancer{
                KubeConfig:      kubeConfig,
                k8sClient:       c,
                MasterClusterIP: masterClusterIP,
        }
        lb.BasePlugin = NewBasePlugin(kubeConfig, lb)
        return lb, nil</span>
}

func (l *LoadBalancer) GetName() string <span class="cov0" title="0">{
        return "load-balancer"
}</span>

func (l *LoadBalancer) Install(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        err := l.UnifiedInstall(kubeConfig, clusterName, ensure...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install loadbalancer: %w", err)
        }</span>
        <span class="cov0" title="0">err = l.deleteValidationWebhookConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete validation webhook config: %w", err)
        }</span>
        <span class="cov0" title="0">err = l.addl2IpPool()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add l2 ip pool: %w", err)
        }</span>
        <span class="cov0" title="0">err = l.addl2Adv()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add l2 advertisement: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (l *LoadBalancer) Uninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        logger.Infoln("Uninstalling loadbalancer")
        return l.UnifiedUninstall(kubeConfig, clusterName, ensure...)
}</span>

func (l *LoadBalancer) Status() string <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        ns, err := l.k8sClient.GetNameSpace(namespace, ctx)
        if ns == "" || err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to get metallb namespace: %v", err)
                return StatusNotInstalled
        }</span>

        <span class="cov0" title="0">return "LoadBalancer is running"</span>
}

func (l *LoadBalancer) addl2IpPool() error <span class="cov0" title="0">{
        ipRange := l.getIPRange()
        ipPooRes := schema.GroupVersionResource{
                Group:    "metallb.io",
                Version:  "v1beta1",
                Resource: "ipaddresspools",
        }

        ipPool := &amp;unstructured.Unstructured{
                Object: map[string]interface{}{
                        "apiVersion": "metallb.io/v1beta1",
                        "kind":       "IPAddressPool",
                        "metadata": map[string]interface{}{
                                "name":      "k3s-pool-ip",
                                "namespace": "metallb-system",
                        },
                        "spec": map[string]interface{}{
                                "addresses": []interface{}{ipRange},
                        },
                },
        }
        ipPool.SetGroupVersionKind(schema.GroupVersionKind{
                Group:   "metallb.io",
                Version: "v1beta1",
                Kind:    "IPAddressPool",
        })

        _, err := l.k8sClient.Dynamic.Resource(ipPooRes).
                Namespace(namespace).
                Create(context.TODO(), ipPool, metav1.CreateOptions{})

        switch </span>{
        case err != nil &amp;&amp; strings.Contains(err.Error(), "already exists"):<span class="cov0" title="0">
                // Get the existing IP address pool to preserve metadata
                existing, getErr := l.k8sClient.Dynamic.Resource(ipPooRes).
                        Namespace(namespace).
                        Get(context.TODO(), "k3s-pool-ip", metav1.GetOptions{})
                if getErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get existing IP address pool: %w", getErr)
                }</span>

                // Preserve the existing metadata and update only the spec
                <span class="cov0" title="0">ipPool.SetResourceVersion(existing.GetResourceVersion())
                ipPool.SetUID(existing.GetUID())
                ipPool.SetCreationTimestamp(existing.GetCreationTimestamp())
                ipPool.SetGeneration(existing.GetGeneration())

                // Copy any existing labels and annotations
                if labels := existing.GetLabels(); labels != nil </span><span class="cov0" title="0">{
                        ipPool.SetLabels(labels)
                }</span>
                <span class="cov0" title="0">if annotations := existing.GetAnnotations(); annotations != nil </span><span class="cov0" title="0">{
                        ipPool.SetAnnotations(annotations)
                }</span>

                <span class="cov0" title="0">_, err = l.k8sClient.Dynamic.Resource(ipPooRes).
                        Namespace(namespace).
                        Update(context.TODO(), ipPool, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update existing IP address pool: %w", err)
                }</span>
                <span class="cov0" title="0">logger.Infoln("Updated existing IP address pool")</span>
        case err != nil:<span class="cov0" title="0">
                logger.Errorln("failed to create ip address pool: %v", err)
                return fmt.Errorf("failed to create ip address pool: %w", err)</span>
        default:<span class="cov0" title="0">
                logger.Successln("Created IP address pool successfully")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (l *LoadBalancer) addl2Adv() error <span class="cov0" title="0">{
        l2AdvRes := schema.GroupVersionResource{
                Group:    "metallb.io",
                Version:  "v1beta1",
                Resource: "l2advertisements",
        }

        l2Adv := &amp;unstructured.Unstructured{
                Object: map[string]interface{}{
                        "apiVersion": "metallb.io/v1beta1",
                        "kind":       "L2Advertisement",
                        "metadata": map[string]interface{}{
                                "name":      "k3s-lb-pool",
                                "namespace": "metallb-system",
                        },
                        "spec": map[string]interface{}{
                                "ipAddressPools": []interface{}{"k3s-pool-ip"},
                        },
                },
        }
        l2Adv.SetGroupVersionKind(schema.GroupVersionKind{
                Group:   "metallb.io",
                Version: "v1beta1",
                Kind:    "L2Advertisement",
        })

        _, err := l.k8sClient.Dynamic.Resource(l2AdvRes).
                Namespace(namespace).
                Create(context.TODO(), l2Adv, metav1.CreateOptions{})

        switch </span>{
        case err != nil &amp;&amp; strings.Contains(err.Error(), "already exists"):<span class="cov0" title="0">
                // Get the existing L2Advertisement to preserve metadata
                existing, getErr := l.k8sClient.Dynamic.Resource(l2AdvRes).
                        Namespace(namespace).
                        Get(context.TODO(), "k3s-lb-pool", metav1.GetOptions{})
                if getErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get existing L2Advertisement: %w", getErr)
                }</span>

                // Preserve the existing metadata and update only the spec
                <span class="cov0" title="0">l2Adv.SetResourceVersion(existing.GetResourceVersion())
                l2Adv.SetUID(existing.GetUID())
                l2Adv.SetCreationTimestamp(existing.GetCreationTimestamp())
                l2Adv.SetGeneration(existing.GetGeneration())

                // Copy any existing labels and annotations
                if labels := existing.GetLabels(); labels != nil </span><span class="cov0" title="0">{
                        l2Adv.SetLabels(labels)
                }</span>
                <span class="cov0" title="0">if annotations := existing.GetAnnotations(); annotations != nil </span><span class="cov0" title="0">{
                        l2Adv.SetAnnotations(annotations)
                }</span>

                <span class="cov0" title="0">_, err = l.k8sClient.Dynamic.Resource(l2AdvRes).
                        Namespace(namespace).
                        Update(context.TODO(), l2Adv, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update existing L2Advertisement: %w", err)
                }</span>
                <span class="cov0" title="0">logger.Infoln("Updated existing L2Advertisement")</span>
        case err != nil:<span class="cov0" title="0">
                logger.Errorln("failed to create l2 advertisement: %v", err)
                return fmt.Errorf("failed to create l2 advertisement: %w", err)</span>
        default:<span class="cov0" title="0">
                logger.Successln("Created L2Advertisement successfully")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (l *LoadBalancer) deleteValidationWebhookConfig() error <span class="cov0" title="0">{
        return l.k8sClient.Clientset.AdmissionregistrationV1().
                ValidatingWebhookConfigurations().
                Delete(context.TODO(), "metallb-webhook-configuration", metav1.DeleteOptions{})
}</span>

func (l *LoadBalancer) getIPRange() string <span class="cov0" title="0">{
        ipParts := strings.Split(l.MasterClusterIP, ".")
        dhcp := ipParts[:3]
        start := fmt.Sprintf("%s.100", strings.Join(dhcp, "."))
        end := fmt.Sprintf("%s.200", strings.Join(dhcp, "."))
        return fmt.Sprintf("%s-%s", start, end)
}</span>

func (l *LoadBalancer) GetNamespace() string <span class="cov0" title="0">{
        return namespace
}</span>

func (l *LoadBalancer) GetVersion() string <span class="cov0" title="0">{
        return chartVersion
}</span>

func (l *LoadBalancer) GetChartName() string <span class="cov0" title="0">{
        return chartName
}</span>

func (l *LoadBalancer) GetRepository() string <span class="cov0" title="0">{
        return repoURL
}</span>

func (l *LoadBalancer) GetChartValues() map[string]interface{} <span class="cov0" title="0">{
        return make(map[string]interface{})
}</span>

func (l *LoadBalancer) GetRepoName() string <span class="cov0" title="0">{
        return repoName
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package plugins

import (
        "context"
        "time"

        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
)

const (
        DefaultNginxReplicas = 2
        NginxNamespace       = "ingress-nginx"
        NginxChartVersion    = "4.11.3"
        NginxChartName       = "ingress-nginx"
        NginxRepoName        = "ingress-nginx"
)

type Nginx struct {
        KubeConfig string
        *BasePlugin
}

func NewNginx(kubeConfig string) *Nginx <span class="cov8" title="1">{
        nginx := &amp;Nginx{
                KubeConfig: kubeConfig,
        }
        nginx.BasePlugin = NewBasePlugin(kubeConfig, nginx)
        return nginx
}</span>

func (n *Nginx) GetName() string <span class="cov8" title="1">{
        return "nginx-ingress"
}</span>

func (n *Nginx) Install(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return n.UnifiedInstall(kubeConfig, clusterName, ensure...)
}</span>

func (n *Nginx) Uninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return n.UnifiedUninstall(kubeConfig, clusterName, ensure...)
}</span>

func (n *Nginx) Status() string <span class="cov8" title="1">{
        if n.KubeConfig == "" </span><span class="cov8" title="1">{
                logger.Errorf("kubeConfig is empty")
                return StatusUnknown
        }</span>

        <span class="cov8" title="1">c, err := k8s.NewK8sClient(n.KubeConfig)
        if err != nil </span><span class="cov8" title="1">{
                logger.Errorf("failed to create k8s client: %v", err)
                return StatusUnknown
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        ns, err := c.GetNameSpace(NginxNamespace, ctx)
        if ns == "" || err != nil </span><span class="cov0" title="0">{
                logger.Debugf("nginx namespace not found or error occurred: %v", err)
                return StatusNotInstalled
        }</span>
        <span class="cov0" title="0">return n.GetName() + " is " + StatusRunning</span>
}

func (n *Nginx) GetNamespace() string <span class="cov8" title="1">{
        return NginxNamespace
}</span>

func (n *Nginx) GetVersion() string <span class="cov8" title="1">{
        return NginxChartVersion
}</span>

func (n *Nginx) GetChartName() string <span class="cov8" title="1">{
        return NginxChartName
}</span>

func (n *Nginx) GetRepository() string <span class="cov8" title="1">{
        return "https://kubernetes.github.io/ingress-nginx"
}</span>

func (n *Nginx) GetRepoName() string <span class="cov8" title="1">{
        return NginxRepoName
}</span>

func (n *Nginx) GetChartValues() map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "controller": map[string]interface{}{
                        "replicaCount": DefaultNginxReplicas,
                        "service": map[string]interface{}{
                                "type": "LoadBalancer",
                        },
                        "config": map[string]interface{}{
                                "enable-vts-status":          "true",
                                "use-forwarded-headers":      "true",
                                "compute-full-forwarded-for": "true",
                                "use-proxy-protocol":         "false",
                        },
                        "metrics": map[string]interface{}{
                                "enabled": true,
                                "serviceMonitor": map[string]interface{}{
                                        "enabled": false,
                                },
                        },
                },
                "defaultBackend": map[string]interface{}{
                        "enabled": true,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package plugins

type Plugin interface {
        GetName() string
        Install(kubeConfig, clusterName string, ensure ...bool) error
        Uninstall(kubeConfig, clusterName string, ensure ...bool) error
        Status() string
        GetNamespace() string
        GetVersion() string
        GetChartName() string
        GetRepository() string
        GetRepoName() string
        GetChartValues() map[string]interface{}
}

func CreatePluginsList(kubeConfig, masterClusterIP, clusterName string) ([]Plugin, error) <span class="cov8" title="1">{
        lb, err := NewLoadBalancer(kubeConfig, masterClusterIP)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ingress, err := NewIngress(kubeConfig, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tls, err := NewTLS(kubeConfig, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return []Plugin{
                NewArgocd(kubeConfig),
                NewCertManager(kubeConfig),
                lb,
                NewNginx(kubeConfig),
                ingress,
                tls,
        }, nil</span>
}

func GetBasicPluginsList() []Plugin <span class="cov8" title="1">{
        return []Plugin{
                NewArgocd(""),
                NewCertManager(""),
                NewNginx(""),
        }
}</span>

var List = GetBasicPluginsList()
</pre>
		
		<pre class="file" id="file23" style="display: none">package plugins

import (
        "context"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/base64"
        "encoding/pem"
        "fmt"
        "math/big"
        "os"
        "runtime"
        "strings"
        "time"

        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

const (
        TLSName              = "tls"
        TLSVersion           = "1.0.0"
        TLSSecretName        = "local-ca-secret"
        TLSClusterIssuerName = "local-ca-issuer"
        CertValidityYears    = 10
        RSAKeySize           = 4096
)

type TLS struct {
        KubeConfig  string
        k8sClient   *k8s.K8sClient
        ClusterName string
        *BasePlugin
}

func NewTLS(kubeConfig, clusterName string) (*TLS, error) <span class="cov8" title="1">{
        c, err := k8s.NewK8sClient(kubeConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create k8s client: %w", err)
        }</span>
        <span class="cov0" title="0">tls := &amp;TLS{
                KubeConfig:  kubeConfig,
                k8sClient:   c,
                ClusterName: clusterName,
        }
        tls.BasePlugin = NewBasePlugin(kubeConfig, tls)
        return tls, nil</span>
}

func (t *TLS) GetName() string <span class="cov0" title="0">{
        return TLSName
}</span>

func (t *TLS) Install(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        logger.Infoln("Installing TLS plugin for cluster: %s", clusterName)

        if err := t.checkDependencies(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dependency check failed: %w", err)
        }</span>

        <span class="cov0" title="0">caCert, caKey, err := t.generateCACertificate()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate CA certificate: %w", err)
        }</span>

        <span class="cov0" title="0">if err := t.storeCASecret(caCert, caKey); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store CA secret: %w", err)
        }</span>

        <span class="cov0" title="0">if err := t.createClusterIssuer(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create cluster issuer: %w", err)
        }</span>

        <span class="cov0" title="0">if err := t.printTrustInstructions(caCert); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to print trust instructions: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Successln("TLS plugin installed successfully")
        return nil</span>
}

func (t *TLS) Uninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        logger.Infoln("Uninstalling TLS plugin")

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        err := t.k8sClient.Clientset.CoreV1().Secrets(CertManagerNamespace).Delete(
                ctx, TLSSecretName, metav1.DeleteOptions{})
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                logger.Warnln("Failed to delete CA secret: %v", err)
        }</span>

        <span class="cov0" title="0">gvr := schema.GroupVersionResource{
                Group:    "cert-manager.io",
                Version:  "v1",
                Resource: "clusterissuers",
        }
        err = t.k8sClient.Dynamic.Resource(gvr).Delete(
                ctx, TLSClusterIssuerName, metav1.DeleteOptions{})
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                logger.Warnln("Failed to delete cluster issuer: %v", err)
        }</span>

        <span class="cov0" title="0">logger.Successln("TLS plugin uninstalled successfully")
        return nil</span>
}

func (t *TLS) Status() string <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        _, err := t.k8sClient.Clientset.CoreV1().Secrets(CertManagerNamespace).Get(
                ctx, TLSSecretName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "TLS CA secret not found"
        }</span>

        <span class="cov0" title="0">gvr := schema.GroupVersionResource{
                Group:    "cert-manager.io",
                Version:  "v1",
                Resource: "clusterissuers",
        }
        _, err = t.k8sClient.Dynamic.Resource(gvr).Get(
                ctx, TLSClusterIssuerName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "TLS cluster issuer not found"
        }</span>

        <span class="cov0" title="0">return "TLS is configured and ready"</span>
}

func (t *TLS) checkDependencies() error <span class="cov0" title="0">{
        logger.Infoln("Checking TLS dependencies...")

        certManager := NewCertManager(t.KubeConfig)
        cmStatus := certManager.Status()
        if !strings.Contains(cmStatus, "running") </span><span class="cov0" title="0">{
                return fmt.Errorf("cert-manager is required but not installed/running. Status: %s", cmStatus)
        }</span>

        <span class="cov0" title="0">logger.Successln("All dependencies satisfied")
        return nil</span>
}

func (t *TLS) generateCACertificate() ([]byte, []byte, error) <span class="cov0" title="0">{
        logger.Infoln("Generating CA certificate for domain: *.%s.local", t.ClusterName)

        privateKey, err := rsa.GenerateKey(rand.Reader, RSAKeySize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to generate private key: %w", err)
        }</span>

        <span class="cov0" title="0">template := x509.Certificate{
                SerialNumber: big.NewInt(1),
                Subject: pkix.Name{
                        Organization:  []string{fmt.Sprintf("%s Local CA", t.ClusterName)},
                        Country:       []string{"US"},
                        Province:      []string{""},
                        Locality:      []string{""},
                        StreetAddress: []string{""},
                        PostalCode:    []string{""},
                },
                NotBefore:             time.Now(),
                NotAfter:              time.Now().AddDate(CertValidityYears, 0, 0),
                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                BasicConstraintsValid: true,
                IsCA:                  true,
                DNSNames: []string{
                        fmt.Sprintf("*.%s.local", t.ClusterName),
                        fmt.Sprintf("%s.local", t.ClusterName),
                },
        }

        certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;privateKey.PublicKey, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create certificate: %w", err)
        }</span>

        <span class="cov0" title="0">certPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "CERTIFICATE",
                Bytes: certDER,
        })

        keyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        })

        logger.Successln("CA certificate generated successfully")
        return certPEM, keyPEM, nil</span>
}

func (t *TLS) storeCASecret(caCert, caKey []byte) error <span class="cov0" title="0">{
        logger.Infoln("Storing CA certificate in Kubernetes secret")

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        secret := &amp;v1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      TLSSecretName,
                        Namespace: CertManagerNamespace,
                },
                Type: v1.SecretTypeOpaque,
                Data: map[string][]byte{
                        "tls.crt": caCert,
                        "tls.key": caKey,
                },
        }

        _, err := t.k8sClient.Clientset.CoreV1().Secrets(CertManagerNamespace).Create(ctx, secret, metav1.CreateOptions{})
        switch </span>{
        case err != nil &amp;&amp; strings.Contains(err.Error(), "already exists"):<span class="cov0" title="0">
                // Get the existing secret to preserve metadata
                existing, getErr := t.k8sClient.Clientset.CoreV1().Secrets(CertManagerNamespace).Get(ctx, TLSSecretName, metav1.GetOptions{})
                if getErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get existing CA secret: %w", getErr)
                }</span>

                // Preserve the existing metadata and update only the data
                <span class="cov0" title="0">secret.ResourceVersion = existing.ResourceVersion
                secret.UID = existing.UID
                secret.CreationTimestamp = existing.CreationTimestamp
                secret.Generation = existing.Generation

                // Copy any existing labels and annotations
                if existing.Labels != nil </span><span class="cov0" title="0">{
                        secret.Labels = existing.Labels
                }</span>
                <span class="cov0" title="0">if existing.Annotations != nil </span><span class="cov0" title="0">{
                        secret.Annotations = existing.Annotations
                }</span>

                <span class="cov0" title="0">_, err = t.k8sClient.Clientset.CoreV1().Secrets(CertManagerNamespace).Update(ctx, secret, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update existing CA secret: %w", err)
                }</span>
                <span class="cov0" title="0">logger.Infoln("Updated existing CA secret")</span>
        case err != nil:<span class="cov0" title="0">
                return fmt.Errorf("failed to create CA secret: %w", err)</span>
        default:<span class="cov0" title="0">
                logger.Successln("Created CA secret successfully")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (t *TLS) createClusterIssuer() error <span class="cov0" title="0">{
        logger.Infoln("Creating cluster issuer: %s", TLSClusterIssuerName)

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        gvr := schema.GroupVersionResource{
                Group:    "cert-manager.io",
                Version:  "v1",
                Resource: "clusterissuers",
        }

        clusterIssuer := &amp;unstructured.Unstructured{
                Object: map[string]interface{}{
                        "apiVersion": "cert-manager.io/v1",
                        "kind":       "ClusterIssuer",
                        "metadata": map[string]interface{}{
                                "name": TLSClusterIssuerName,
                        },
                        "spec": map[string]interface{}{
                                "ca": map[string]interface{}{
                                        "secretName": TLSSecretName,
                                },
                        },
                },
        }

        _, err := t.k8sClient.Dynamic.Resource(gvr).Create(ctx, clusterIssuer, metav1.CreateOptions{})
        switch </span>{
        case err != nil &amp;&amp; strings.Contains(err.Error(), "already exists"):<span class="cov0" title="0">
                // Get the existing cluster issuer to preserve metadata
                existing, getErr := t.k8sClient.Dynamic.Resource(gvr).Get(ctx, TLSClusterIssuerName, metav1.GetOptions{})
                if getErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get existing cluster issuer: %w", getErr)
                }</span>

                // Preserve the existing metadata and update only the spec
                <span class="cov0" title="0">clusterIssuer.SetResourceVersion(existing.GetResourceVersion())
                clusterIssuer.SetUID(existing.GetUID())
                clusterIssuer.SetCreationTimestamp(existing.GetCreationTimestamp())
                clusterIssuer.SetGeneration(existing.GetGeneration())

                // Copy any existing labels and annotations
                if labels := existing.GetLabels(); labels != nil </span><span class="cov0" title="0">{
                        clusterIssuer.SetLabels(labels)
                }</span>
                <span class="cov0" title="0">if annotations := existing.GetAnnotations(); annotations != nil </span><span class="cov0" title="0">{
                        clusterIssuer.SetAnnotations(annotations)
                }</span>

                <span class="cov0" title="0">_, err = t.k8sClient.Dynamic.Resource(gvr).Update(ctx, clusterIssuer, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update existing cluster issuer: %w", err)
                }</span>
                <span class="cov0" title="0">logger.Infoln("Updated existing cluster issuer")</span>
        case err != nil:<span class="cov0" title="0">
                return fmt.Errorf("failed to create cluster issuer: %w", err)</span>
        default:<span class="cov0" title="0">
                logger.Successln("Created cluster issuer successfully")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (t *TLS) printMacOSInstructions(tempFile *os.File) <span class="cov0" title="0">{
        logger.Infoln("🍎 macOS Trust Instructions:")
        logger.Infoln("sudo security add-trusted-cert -d -r trustRoot \\")
        logger.Infoln("  -k /Library/Keychains/System.keychain %s", tempFile.Name())
        logger.Infoln("")
        logger.Infoln("Alternative (GUI method):")
        logger.Infoln("1. Double-click the certificate file to open Keychain Access")
        logger.Infoln("2. Select 'System' keychain")
        logger.Infoln("3. Find the certificate and double-click it")
        logger.Infoln("4. Expand 'Trust' and set 'When using this certificate' to 'Always Trust'")
}</span>

func (t *TLS) printLinuxInstructions(tempFile *os.File) <span class="cov0" title="0">{
        logger.Infoln("🐧 Linux Trust Instructions:")
        logger.Infoln("sudo cp %s /usr/local/share/ca-certificates/%s-ca.crt", tempFile.Name(), t.ClusterName)
        logger.Infoln("sudo update-ca-certificates")
        logger.Infoln("")
        logger.Infoln("For Firefox (if needed):")
        logger.Infoln("Import the certificate manually in Firefox preferences &gt; Privacy &amp; Security &gt; Certificates")
}</span>

func (t *TLS) printWindowsInstructions(tempFile *os.File) <span class="cov0" title="0">{
        logger.Infoln("🪟 Windows Trust Instructions:")
        logger.Infoln("certlm.msc")
        logger.Infoln("1. Right-click 'Trusted Root Certification Authorities'")
        logger.Infoln("2. Select 'All Tasks' &gt; 'Import'")
        logger.Infoln("3. Browse and select: %s", tempFile.Name())
        logger.Infoln("4. Place in 'Trusted Root Certification Authorities' store")
        logger.Infoln("")
        logger.Infoln("Alternative (PowerShell as Administrator):")
        logger.Infoln("Import-Certificate -FilePath \"%s\" -CertStoreLocation Cert:\\LocalMachine\\Root", tempFile.Name())
}</span>

func (t *TLS) printGenericInstructions(tempFile *os.File) <span class="cov0" title="0">{
        logger.Infoln("📋 Generic Trust Instructions:")
        logger.Infoln("Add the following certificate to your system's trusted CA store:")
        logger.Infoln("Certificate file: %s", tempFile.Name())
}</span>

func (t *TLS) printTrustInstructions(caCert []byte) error <span class="cov0" title="0">{
        logger.Infoln("Generating trust instructions for your operating system")

        tempFile, err := os.CreateTemp("", fmt.Sprintf("%s-ca-*.crt", t.ClusterName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temporary file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := tempFile.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debugln("Failed to close temporary file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">if _, err := tempFile.Write(caCert); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write certificate to temp file: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Infoln("")
        logger.Infoln("🔐 CA Certificate has been generated!")
        logger.Infoln("📍 Temporary certificate file: %s", tempFile.Name())
        logger.Infoln("")

        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                t.printMacOSInstructions(tempFile)</span>
        case "linux":<span class="cov0" title="0">
                t.printLinuxInstructions(tempFile)</span>
        case "windows":<span class="cov0" title="0">
                t.printWindowsInstructions(tempFile)</span>
        default:<span class="cov0" title="0">
                t.printGenericInstructions(tempFile)</span>
        }

        <span class="cov0" title="0">logger.Infoln("")
        logger.Infoln("🎯 Certificate Details:")
        logger.Infoln("Domain: *.%s.local", t.ClusterName)
        logger.Infoln("Validity: %d years", CertValidityYears)
        logger.Infoln("Cluster Issuer: %s", TLSClusterIssuerName)
        logger.Infoln("")
        logger.Infoln("🚀 You can now use TLS certificates in your cluster!")
        logger.Infoln("Example ingress annotation: cert-manager.io/cluster-issuer: %s", TLSClusterIssuerName)

        logger.Infoln("")
        logger.Infoln("📋 Certificate content (base64):")
        certBase64 := base64.StdEncoding.EncodeToString(caCert)
        logger.Infoln(certBase64)

        return nil</span>
}

func (t *TLS) GetClusterIssuerName() string <span class="cov0" title="0">{
        return TLSClusterIssuerName
}</span>

func (t *TLS) GetNamespace() string <span class="cov0" title="0">{
        return CertManagerNamespace
}</span>

func (t *TLS) GetVersion() string <span class="cov0" title="0">{
        return TLSVersion
}</span>

func (t *TLS) GetChartName() string <span class="cov0" title="0">{
        return ""
}</span>

func (t *TLS) GetRepository() string <span class="cov0" title="0">{
        return ""
}</span>

func (t *TLS) GetRepoName() string <span class="cov0" title="0">{
        return ""
}</span>

func (t *TLS) GetChartValues() map[string]interface{} <span class="cov0" title="0">{
        return make(map[string]interface{})
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package plugins

import (
        "context"
        "time"

        "github.com/mrgb7/playground/internal/installer"
        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        ArgocdInstallNamespace    = "argocd"
        ArgocdServerLabelSelector = "app.kubernetes.io/name=argocd-server"
)

func IsArgoCDRunning(kubeConfig string) bool <span class="cov8" title="1">{
        client, err := k8s.NewK8sClient(kubeConfig)
        if err != nil </span><span class="cov8" title="1">{
                logger.Debugln("Failed to create k8s client: %v", err)
                return false
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        namespace, err := client.GetNameSpace(ArgocdInstallNamespace, ctx)
        if err != nil || namespace == "" </span><span class="cov8" title="1">{
                logger.Debugln("ArgoCD namespace not found: %v", err)
                return false
        }</span>

        <span class="cov0" title="0">podList, err := client.Clientset.CoreV1().Pods(ArgocdInstallNamespace).List(ctx, metav1.ListOptions{
                LabelSelector: ArgocdServerLabelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Debugln("Failed to list ArgoCD server pods: %v", err)
                return false
        }</span>

        <span class="cov0" title="0">if len(podList.Items) == 0 </span><span class="cov0" title="0">{
                logger.Debugln("No ArgoCD server pods found")
                return false
        }</span>

        <span class="cov0" title="0">for _, pod := range podList.Items </span><span class="cov0" title="0">{
                if pod.Status.Phase == "Running" </span><span class="cov0" title="0">{
                        readyContainers := 0
                        totalContainers := len(pod.Status.ContainerStatuses)

                        for _, containerStatus := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                                if containerStatus.Ready </span><span class="cov0" title="0">{
                                        readyContainers++
                                }</span>
                        }

                        <span class="cov0" title="0">if readyContainers == totalContainers &amp;&amp; totalContainers &gt; 0 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">logger.Debugln("ArgoCD pods are not ready")
        return false</span>
}

func NewInstaller(plugin Plugin, kubeConfig, clusterName string) (installer.Installer, error) <span class="cov8" title="1">{
        if IsArgoCDRunning(kubeConfig) </span><span class="cov0" title="0">{
                argoInstaller, err := installer.NewArgoInstaller(kubeConfig, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Failed to create ArgoCD installer: %v", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">return argoInstaller, nil</span>
        }

        <span class="cov8" title="1">return installer.NewHelmInstaller(kubeConfig)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package main

import (
        "github.com/mrgb7/playground/cmd/root"
)

func main() <span class="cov0" title="0">{
        root.Execute()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package logger

import (
        "fmt"
        "io"
        "os"

        "github.com/fatih/color"
)

var (
        infoColor    = color.New(color.FgGreen)
        warnColor    = color.New(color.FgYellow)
        errorColor   = color.New(color.FgRed)
        debugColor   = color.New(color.FgCyan)
        successColor = color.New(color.FgGreen, color.Bold)
)

// Info prints info message with format
func Info(format string, args ...interface{}) <span class="cov8" title="1">{
        _, _ = infoColor.Printf(format, args...)
}</span>

// Infof is an alias for Info for consistency
func Infof(format string, args ...interface{}) <span class="cov0" title="0">{
        Info(format, args...)
}</span>

// Infoln prints info message with newline
func Infoln(format string, args ...interface{}) <span class="cov8" title="1">{
        _, _ = infoColor.Printf(format+"\n", args...)
}</span>

// Warn prints warning message with format
func Warn(format string, args ...interface{}) <span class="cov8" title="1">{
        _, _ = warnColor.Printf(format, args...)
}</span>

// Warnf is an alias for Warn for consistency
func Warnf(format string, args ...interface{}) <span class="cov0" title="0">{
        Warn(format, args...)
}</span>

// Warnln prints warning message with newline
func Warnln(format string, args ...interface{}) <span class="cov8" title="1">{
        _, _ = warnColor.Printf(format+"\n", args...)
}</span>

// Error prints error message with format
func Error(format string, args ...interface{}) <span class="cov8" title="1">{
        _, _ = errorColor.Printf(format, args...)
}</span>

// Errorf is an alias for Error for consistency
func Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        Error(format, args...)
}</span>

// Errorln prints error message with newline
func Errorln(format string, args ...interface{}) <span class="cov8" title="1">{
        _, _ = errorColor.Printf(format+"\n", args...)
}</span>

// Debug prints debug message with format
func Debug(format string, args ...interface{}) <span class="cov8" title="1">{
        _, _ = debugColor.Printf(format, args...)
}</span>

// Debugf is an alias for Debug for consistency
func Debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        Debug(format, args...)
}</span>

// Debugln prints debug message with newline
func Debugln(format string, args ...interface{}) <span class="cov8" title="1">{
        _, _ = debugColor.Printf(format+"\n", args...)
}</span>

// Success prints success message with format
func Success(format string, args ...interface{}) <span class="cov8" title="1">{
        _, _ = successColor.Printf(format, args...)
}</span>

// Successf is an alias for Success for consistency
func Successf(format string, args ...interface{}) <span class="cov0" title="0">{
        Success(format, args...)
}</span>

// Successln prints success message with newline
func Successln(format string, args ...interface{}) <span class="cov8" title="1">{
        _, _ = successColor.Printf(format+"\n", args...)
}</span>

// Fatal prints error message and exits
func Fatal(format string, args ...interface{}) <span class="cov0" title="0">{
        _, _ = errorColor.Printf(format+"\n", args...)
        os.Exit(1)
}</span>

// Print prints plain message with format
func Print(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf(format, args...)
}</span>

// Println prints plain message with newline
func Println(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf(format+"\n", args...)
}</span>

// GetWriter returns an io.Writer for use with external libraries
func GetWriter() io.Writer <span class="cov0" title="0">{
        return os.Stdout
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package types

import (
        "fmt"
        "strings"

        "github.com/mrgb7/playground/internal/multipass"
)

type Cluster struct {
        Name       string
        Nodes      []*Node
        KubeConfig string
}

func Get(clusterName string, load *bool) *Cluster <span class="cov0" title="0">{
        return nil
}</span>

func (c *Cluster) GetMaster() *Node <span class="cov0" title="0">{
        for _, node := range c.Nodes </span><span class="cov0" title="0">{
                if strings.HasSuffix(node.Name, "master") </span><span class="cov0" title="0">{
                        return node
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (c *Cluster) GetWorkers() []*Node <span class="cov0" title="0">{
        workers := []*Node{}
        for _, node := range c.Nodes </span><span class="cov0" title="0">{
                if !strings.HasSuffix(node.Name, "master") </span><span class="cov0" title="0">{
                        workers = append(workers, node)
                }</span>
        }
        <span class="cov0" title="0">return workers</span>
}

func (c *Cluster) SetKubeConfig() error <span class="cov0" title="0">{
        masterNodeName := fmt.Sprintf("%s-master", c.Name)
        cl := multipass.NewMultipassClient()
        masterIP, err := cl.GetNodeIP(masterNodeName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get master node IP: %w", err)
        }</span>
        <span class="cov0" title="0">res, err := cl.ExecuteShell(masterNodeName, "sudo cat /etc/rancher/k3s/k3s.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get kubeconfig: %w", err)
        }</span>
        <span class="cov0" title="0">res = strings.ReplaceAll(res, "127.0.0.1", masterIP)
        c.KubeConfig = res
        return nil</span>
}

func (c *Cluster) GetMasterIP() string <span class="cov0" title="0">{
        masterNodeName := fmt.Sprintf("%s-master", c.Name)
        cl := multipass.NewMultipassClient()
        masterIP, err := cl.GetNodeIP(masterNodeName)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return masterIP</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
