
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cluster: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mrgb7/playground/cmd/cluster/clean.go (5.0%)</option>
				
				<option value="file1">github.com/mrgb7/playground/cmd/cluster/cluster.go (100.0%)</option>
				
				<option value="file2">github.com/mrgb7/playground/cmd/cluster/create.go (3.1%)</option>
				
				<option value="file3">github.com/mrgb7/playground/cmd/cluster/delete.go (4.2%)</option>
				
				<option value="file4">github.com/mrgb7/playground/cmd/cluster/plugin/add.go (0.0%)</option>
				
				<option value="file5">github.com/mrgb7/playground/cmd/cluster/plugin/get.go (0.0%)</option>
				
				<option value="file6">github.com/mrgb7/playground/cmd/cluster/plugin/list.go (0.0%)</option>
				
				<option value="file7">github.com/mrgb7/playground/cmd/cluster/plugin/plugin.go (0.0%)</option>
				
				<option value="file8">github.com/mrgb7/playground/cmd/cluster/plugin/remove.go (0.0%)</option>
				
				<option value="file9">github.com/mrgb7/playground/cmd/root/root.go (0.0%)</option>
				
				<option value="file10">github.com/mrgb7/playground/cmd/root/version.go (0.0%)</option>
				
				<option value="file11">github.com/mrgb7/playground/internal/installer/argo.go (9.5%)</option>
				
				<option value="file12">github.com/mrgb7/playground/internal/installer/helm.go (0.0%)</option>
				
				<option value="file13">github.com/mrgb7/playground/internal/k8s/client.go (0.0%)</option>
				
				<option value="file14">github.com/mrgb7/playground/internal/multipass/client.go (8.9%)</option>
				
				<option value="file15">github.com/mrgb7/playground/internal/plugins/argocd.go (0.0%)</option>
				
				<option value="file16">github.com/mrgb7/playground/internal/plugins/base.go (0.0%)</option>
				
				<option value="file17">github.com/mrgb7/playground/internal/plugins/certmanager.go (0.0%)</option>
				
				<option value="file18">github.com/mrgb7/playground/internal/plugins/loadbalancer.go (0.0%)</option>
				
				<option value="file19">github.com/mrgb7/playground/internal/plugins/nginx.go (0.0%)</option>
				
				<option value="file20">github.com/mrgb7/playground/internal/plugins/plugin.go (0.0%)</option>
				
				<option value="file21">github.com/mrgb7/playground/internal/plugins/utils.go (34.3%)</option>
				
				<option value="file22">github.com/mrgb7/playground/main.go (0.0%)</option>
				
				<option value="file23">github.com/mrgb7/playground/pkg/logger/logger.go (60.0%)</option>
				
				<option value="file24">github.com/mrgb7/playground/types/Cluster.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cluster

import (
        "sync"

        "github.com/mrgb7/playground/internal/multipass"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
)

var (
        cPurge bool
)

var cleanCmd = &amp;cobra.Command{
        Use:   "clean",
        Short: "Clean up cluster resources",
        Long:  `Clean up cluster resources, including stopping and removing nodes`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                var wg sync.WaitGroup
                client := multipass.NewMultipassClient()

                if !client.IsMultipassInstalled() </span><span class="cov0" title="0">{
                        logger.Errorln("Error: Multipass is not installed or not in PATH. Please install Multipass first.")
                        return
                }</span>

                <span class="cov0" title="0">if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        clusterName := args[0]
                        logger.Infoln("Cleaning up resources for cluster '%s'...", clusterName)

                        if err := client.DeleteCluster(clusterName, &amp;wg); err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("Failed to clean up cluster: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">wg.Wait()

                        logger.Successln("Successfully cleaned up cluster '%s'", clusterName)</span>
                }

                <span class="cov0" title="0">if cPurge || len(args) == 0 </span><span class="cov0" title="0">{
                        logger.Infoln("Purging all deleted instances...")
                        if err := client.PurgeNodes(); err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("Failed to purge deleted instances: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Successln("Successfully purged all deleted instances")</span>
                }
        },
}

func init() <span class="cov8" title="1">{
        cleanCmd.Flags().BoolVarP(&amp;cPurge, "purge", "p", false, "Purge all resources")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cluster

import (
        "github.com/mrgb7/playground/cmd/cluster/plugin"
        "github.com/spf13/cobra"
)

var ClusterCmd = &amp;cobra.Command{
        Use:   "cluster",
        Short: "Manage clusters",
        Long:  `Commands to create, delete, and get information about clusters`,
}

func init() <span class="cov8" title="1">{
        ClusterCmd.AddCommand(plugin.PluginCmd)
        ClusterCmd.AddCommand(createCmd)
        ClusterCmd.AddCommand(deleteCmd)
        ClusterCmd.AddCommand(cleanCmd)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cluster

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "sync"

        "github.com/mrgb7/playground/internal/multipass"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/clientcmd/api"
        "k8s.io/client-go/util/homedir"
)

// ClusterConfig holds the configuration for cluster creation
type ClusterConfig struct {
        Name               string
        Size               int
        WithCoreComponents bool
}

// workerError represents an error that occurred while configuring a worker node
type workerError struct {
        nodeName string
        err      error
}

var (
        cCreateName        string
        cCreateSize        int
        withCoreComponents bool
)

const (
        K3sCreateMasterCmd   = `curl -sfL https://get.k3s.io | sh -s - --disable=servicelb --disable=traefik`
        GetAccessTokenCmd    = `sudo cat /var/lib/rancher/k3s/server/node-token`
        K3sCreateWorkerCmd   = `curl -sfL https://get.k3s.io | K3S_URL=https://%s:6443 K3S_TOKEN=%s  sh -`
        KubeConfigCmd        = `sudo cat /etc/rancher/k3s/k3s.yaml`
        K3sInstallTimeout    = 300 // seconds - timeout for K3s installation
        MaxClusterSize       = 10  // maximum number of nodes allowed in cluster
        MaxClusterNameLength = 63  // maximum length for cluster name (DNS label limit)
        MinClusterSize       = 1   // minimum number of nodes in cluster
)

func validateClusterName(name string) error <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster name cannot be empty")
        }</span>
        
        <span class="cov0" title="0">matched, err := regexp.MatchString(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`, name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error validating cluster name: %w", err)
        }</span>
        
        <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster name must start and end with alphanumeric characters and contain only lowercase letters, numbers, and hyphens")
        }</span>
        
        <span class="cov0" title="0">if len(name) &gt; MaxClusterNameLength </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster name must be %d characters or less", MaxClusterNameLength)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func validateClusterSize(size int) error <span class="cov0" title="0">{
        if size &lt; MinClusterSize </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster size must be at least %d", MinClusterSize)
        }</span>
        
        <span class="cov0" title="0">if size &gt; MaxClusterSize </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster size cannot exceed %d nodes", MaxClusterSize)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

var createCmd = &amp;cobra.Command{
        Use:   "create",
        Short: "Create a new cluster",
        Long:  `Create a new cluster with the specified configurations`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                config := &amp;ClusterConfig{
                        Name:               cCreateName,
                        Size:               cCreateSize,
                        WithCoreComponents: withCoreComponents,
                }
                
                if err := createCluster(config); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Failed to create cluster: %v", err)
                        return
                }</span>
        },
}

func createCluster(config *ClusterConfig) error <span class="cov0" title="0">{
        if err := validateClusterName(config.Name); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cluster name: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := validateClusterSize(config.Size); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cluster size: %w", err)
        }</span>
        
        <span class="cov0" title="0">client := multipass.NewMultipassClient()
        if !client.IsMultipassInstalled() </span><span class="cov0" title="0">{
                return fmt.Errorf("multipass is not installed or not in PATH")
        }</span>

        <span class="cov0" title="0">return executeClusterCreation(client, config)</span>
}

func executeClusterCreation(client multipass.Client, config *ClusterConfig) error <span class="cov0" title="0">{
        var wg sync.WaitGroup
        
        if err := client.CreateCluster(config.Name, config.Size, &amp;wg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create cluster: %w", err)
        }</span>
        
        <span class="cov0" title="0">masterNodeName := fmt.Sprintf("%s-master", config.Name)
        
        // Install K3s on master node
        if err := installMasterNode(client, masterNodeName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install K3s on master: %w", err)
        }</span>

        // Get access token and master IP
        <span class="cov0" title="0">accessToken, masterIP, err := getMasterCredentials(client, masterNodeName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get master credentials: %w", err)
        }</span>
        
        // Configure worker nodes
        <span class="cov0" title="0">workerErrors := configureWorkerNodes(client, config, masterIP, accessToken)
        
        // Report results
        reportClusterCreationResults(config, workerErrors)
        
        // Update kubeconfig
        return updateKubeConfig(client, masterNodeName, config.Name)</span>
}

func installMasterNode(client multipass.Client, masterNodeName string) error <span class="cov0" title="0">{
        std, err := client.ExecuteShellWithTimeout(masterNodeName, K3sCreateMasterCmd, K3sInstallTimeout)
        if err != nil || std == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create k3s on master: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getMasterCredentials(client multipass.Client, masterNodeName string) (string, string, error) <span class="cov0" title="0">{
        accessToken, err := client.ExecuteShell(masterNodeName, GetAccessTokenCmd)
        if err != nil || accessToken == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to get access token: %w", err)
        }</span>
        <span class="cov0" title="0">accessToken = strings.TrimSpace(accessToken)
        
        masterIP, err := client.GetNodeIP(masterNodeName)
        if err != nil || masterIP == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to get master node IP: %w", err)
        }</span>
        
        <span class="cov0" title="0">return accessToken, masterIP, nil</span>
}

func configureWorkerNodes(client multipass.Client, config *ClusterConfig, masterIP, accessToken string) []workerError <span class="cov0" title="0">{
        workerErrors := make([]workerError, 0)
        var workerErrorsMutex sync.Mutex
        var wg sync.WaitGroup
        
        for i := 0; i &lt; config.Size-1; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(i int) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        nodeName := fmt.Sprintf("%s-worker-%d", config.Name, i+1)
                        _, err := client.ExecuteShellWithTimeout(
                                nodeName,
                                fmt.Sprintf(K3sCreateWorkerCmd, masterIP, accessToken),
                                K3sInstallTimeout,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                workerErrorsMutex.Lock()
                                workerErrors = append(workerErrors, workerError{
                                        nodeName: nodeName,
                                        err:      err,
                                })
                                workerErrorsMutex.Unlock()
                                logger.Errorln("Failed to install K3S on worker node %s: %v", nodeName, err)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Successf("Successfully configured worker node: %s\n", nodeName)
                        }</span>
                }(i)
        }
        <span class="cov0" title="0">wg.Wait()
        
        return workerErrors</span>
}

func reportClusterCreationResults(config *ClusterConfig, workerErrors []workerError) <span class="cov0" title="0">{
        if len(workerErrors) &gt; 0 </span><span class="cov0" title="0">{
                logger.Warnln("Some worker nodes failed to configure properly:")
                for _, we := range workerErrors </span><span class="cov0" title="0">{
                        logger.Errorln("  - %s: %v", we.nodeName, we.err)
                }</span>
                <span class="cov0" title="0">logger.Warnln("Cluster created with %d/%d worker nodes successfully configured", 
                        config.Size-1-len(workerErrors), config.Size-1)</span>
        } else<span class="cov0" title="0"> {
                logger.Successln("Successfully created cluster '%s' with %d nodes", config.Name, config.Size)
        }</span>
}

func updateKubeConfig(client multipass.Client, masterNodeName, clusterName string) error <span class="cov0" title="0">{
        logger.Infoln("Attempting to update kubeconfig...")
        
        kubConfig, err := client.ExecuteShell(masterNodeName, KubeConfigCmd)
        if err != nil || kubConfig == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get kube config: %w", err)
        }</span>
        
        // Get master IP to replace 127.0.0.1 in kubeconfig
        <span class="cov0" title="0">masterIP, err := client.GetNodeIP(masterNodeName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get master IP: %w", err)
        }</span>
        
        // Replace localhost with master IP
        <span class="cov0" title="0">kubConfig = strings.ReplaceAll(kubConfig, "127.0.0.1", masterIP)
        
        if err := createKubeConfigFile(kubConfig, clusterName); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Failed to update kubeconfig: %v", err)
                logger.Warnln("Cluster created successfully, but kubeconfig update failed.")
                logger.Infof("You can manually retrieve the kubeconfig using: playground cluster kubeconfig --name %s\n", clusterName)
                return err
        }</span>
        
        <span class="cov0" title="0">logger.Successln("Successfully updated kubeconfig.")
        return nil</span>
}

func createKubeConfigFile(kubeConfig, clusterName string) error <span class="cov0" title="0">{
        // Use client-go to properly parse the K3s kubeconfig format
        newConfig, err := clientcmd.Load([]byte(kubeConfig))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse new kubeconfig: %w", err)
        }</span>
        
        // Update context and cluster names to include cluster name
        <span class="cov0" title="0">contextName := fmt.Sprintf("%s-context", clusterName)
        clusterKey := fmt.Sprintf("%s-cluster", clusterName)
        userKey := fmt.Sprintf("%s-user", clusterName)
        
        // Rename the default entries to use cluster-specific names
        if cluster, exists := newConfig.Clusters["default"]; exists </span><span class="cov0" title="0">{
                delete(newConfig.Clusters, "default")
                newConfig.Clusters[clusterKey] = cluster
        }</span>
        
        <span class="cov0" title="0">if authInfo, exists := newConfig.AuthInfos["default"]; exists </span><span class="cov0" title="0">{
                delete(newConfig.AuthInfos, "default")
                newConfig.AuthInfos[userKey] = authInfo
        }</span>
        
        <span class="cov0" title="0">if context, exists := newConfig.Contexts["default"]; exists </span><span class="cov0" title="0">{
                delete(newConfig.Contexts, "default")
                context.Cluster = clusterKey
                context.AuthInfo = userKey
                newConfig.Contexts[contextName] = context
        }</span>
        
        // Set current context to the new cluster
        <span class="cov0" title="0">newConfig.CurrentContext = contextName

        kubeconfigPath := filepath.Join(homedir.HomeDir(), ".kube", "config")
        var existingConfig *api.Config

        if _, err := os.Stat(kubeconfigPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                existingConfig = api.NewConfig()
        }</span> else<span class="cov0" title="0"> {
                existingConfig, err = clientcmd.LoadFromFile(kubeconfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load existing kubeconfig: %w", err)
                }</span>
        }

        // Merge configurations
        <span class="cov0" title="0">for name, cluster := range newConfig.Clusters </span><span class="cov0" title="0">{
                existingConfig.Clusters[name] = cluster
        }</span>

        <span class="cov0" title="0">for name, authInfo := range newConfig.AuthInfos </span><span class="cov0" title="0">{
                existingConfig.AuthInfos[name] = authInfo
        }</span>

        <span class="cov0" title="0">for name, context := range newConfig.Contexts </span><span class="cov0" title="0">{
                existingConfig.Contexts[name] = context
        }</span>

        // Set current context to the new cluster
        <span class="cov0" title="0">existingConfig.CurrentContext = contextName

        if err := clientcmd.WriteToFile(*existingConfig, kubeconfigPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write merged kubeconfig: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        createCmd.Flags().StringVarP(&amp;cCreateName, "name", "n", "", "Name for the cluster (required)")
        createCmd.Flags().IntVarP(&amp;cCreateSize, "size", "s", 1, "Number of nodes in the cluster")
        createCmd.Flags().BoolVarP(&amp;withCoreComponents, "with-core-component", "c", false, "Install core components (nginx,cert-manager)")
        createCmd.MarkFlagRequired("name")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cluster

import (
        "sync"

        "github.com/mrgb7/playground/internal/multipass"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
)

var (
        cDeleteForce bool
        deleteCmd    = &amp;cobra.Command{
                Use:   "delete",
                Short: "Delete an existing cluster",
                Long:  `Delete an existing cluster by specifying its name`,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        var wg sync.WaitGroup
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                logger.Errorln("Error: Cluster name is required")
                                cmd.Help()
                                return
                        }</span>

                        <span class="cov0" title="0">clusterToDelete := args[0]

                        client := multipass.NewMultipassClient()

                        if !client.IsMultipassInstalled() </span><span class="cov0" title="0">{
                                logger.Errorln("Error: Multipass is not installed or not in PATH. Please install Multipass first.")
                                return
                        }</span>

                        <span class="cov0" title="0">if clusterToDelete == "" </span><span class="cov0" title="0">{
                                logger.Errorln("Error: Please provide a valid cluster name to delete.")
                                return
                        }</span>
                        <span class="cov0" title="0">if err := client.DeleteCluster(clusterToDelete, &amp;wg); err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("Failed to delete cluster: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">wg.Wait()

                        if cDeleteForce </span><span class="cov0" title="0">{
                                logger.Infoln("Purging deleted instances...")
                                if err := client.PurgeNodes(); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorln("Failed to purge deleted instances: %v", err)
                                        return
                                }</span>

                        }

                        <span class="cov0" title="0">logger.Successln("Successfully deleted cluster '%s'", clusterToDelete)</span>
                },
        }
)

func init() <span class="cov8" title="1">{
        deleteCmd.Flags().BoolVarP(&amp;cDeleteForce, "force", "f", false, "Force delete cluster resources")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package plugin

import (
        "github.com/mrgb7/playground/internal/plugins"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/mrgb7/playground/types"
        "github.com/spf13/cobra"
)

var (
        pName string
        cName string
)

var addCmd = &amp;cobra.Command{
        Use:   "add",
        Short: "Add a new plugin",
        Long:  `Add a new plugin to the cluster`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                c := types.Cluster{
                        Name: cName,
                }

                ip := c.GetMasterIP()
                c.SetKubeConfig()

                pluginsList, err := plugins.CreatePluginsList(c.KubeConfig, ip)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Failed to create plugins list: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">found := false
                for _, plugin := range pluginsList </span><span class="cov0" title="0">{
                        if plugin.GetName() == pName </span><span class="cov0" title="0">{
                                found = true
                                
                                err := plugin.Install(c.KubeConfig, c.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorln("Error installing plugin: %v", err)
                                }</span> else<span class="cov0" title="0"> {
                                        logger.Successln("Successfully installed %s", pName)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
                
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        logger.Errorln("Plugin %s not found", pName)
                        logger.Infoln("Available plugins:")
                        for _, plugin := range pluginsList </span><span class="cov0" title="0">{
                                logger.Infoln("  - %s", plugin.GetName())
                        }</span>
                }
        },
}

func init() <span class="cov0" title="0">{
        flags := addCmd.Flags()
        flags.StringVarP(&amp;pName, "name", "n", "", "Name of the plugin")
        flags.StringVarP(&amp;cName, "cluster", "c", "", "Name of the cluster")
        addCmd.MarkFlagRequired("name")
        addCmd.MarkFlagRequired("cluster")
        PluginCmd.AddCommand(addCmd)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package plugin

import (
        "github.com/mrgb7/playground/internal/plugins"
        "github.com/spf13/cobra"
)

var getCmd = &amp;cobra.Command{
        Use:   "get",
        Short: "Get a plugin",
        Long:  "Get a plugin for the cluster",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        found := false
                        for _, plugin := range plugins.List </span><span class="cov0" title="0">{
                                if plugin.GetName() == args[0] </span><span class="cov0" title="0">{
                                        println(plugin.GetName())
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                println("Plugin not found", args[0])
                        }</span>
                }
        },
}

func init() <span class="cov0" title="0">{
        PluginCmd.AddCommand(getCmd)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package plugin

import (
        "github.com/mrgb7/playground/internal/plugins"
        "github.com/spf13/cobra"
)

var listCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all available plugins",
        Long:  `List all available plugins for the cluster`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                for _, plugin := range plugins.List </span><span class="cov0" title="0">{
                        println(plugin.GetName(), plugin.Status())
                }</span>
        },
}

func init() <span class="cov0" title="0">{
        PluginCmd.AddCommand(listCmd)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package plugin

import (
        "github.com/spf13/cobra"
)

var PluginCmd = &amp;cobra.Command{
        Use:   "plugin",
        Short: "Manage plugins",
        Long:  `Manage plugins for the cluster`,
}

func init() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package plugin

import (
        "github.com/mrgb7/playground/internal/plugins"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/mrgb7/playground/types"
        "github.com/spf13/cobra"
)

var removeCmd = &amp;cobra.Command{
        Use:   "remove",
        Short: "remove plugin",
        Long:  `Remove plugin from the cluster`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                c := types.Cluster{
                        Name: cName,
                }

                ip := c.GetMasterIP()
                c.SetKubeConfig()

                pluginsList, err := plugins.CreatePluginsList(c.KubeConfig, ip)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Failed to create plugins list: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">found := false
                for _, plugin := range pluginsList </span><span class="cov0" title="0">{
                        if plugin.GetName() == pName </span><span class="cov0" title="0">{
                                found = true
                                
                                err := plugin.Uninstall(c.KubeConfig, c.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorln("Error uninstalling plugin: %v", err)
                                }</span> else<span class="cov0" title="0"> {
                                        logger.Successln("Successfully uninstalled %s", pName)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
                
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        logger.Errorln("Plugin %s not found", pName)
                        logger.Infoln("Available plugins:")
                        for _, plugin := range pluginsList </span><span class="cov0" title="0">{
                                logger.Infoln("  - %s", plugin.GetName())
                        }</span>
                }
        },
}

func init() <span class="cov0" title="0">{
        flags := removeCmd.Flags()
        flags.StringVarP(&amp;pName, "name", "n", "", "Name of the plugin")
        flags.StringVarP(&amp;cName, "cluster", "c", "", "Name of the cluster")
        removeCmd.MarkFlagRequired("name")
        removeCmd.MarkFlagRequired("cluster")
        PluginCmd.AddCommand(removeCmd)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package root

import (
        "os"

        "github.com/mrgb7/playground/cmd/cluster"
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{
        Use:   "playground",
        Short: "A brief description of your application",
        Long: `A longer description that spans multiple lines and likely contains
examples and usage of using your application.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                logger.Infoln("Hello from playground CLI!")
        }</span>,
}

func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Error: %v", err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
        rootCmd.AddCommand(cluster.ClusterCmd)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package root

import (
        "github.com/mrgb7/playground/pkg/logger"
        "github.com/spf13/cobra"
)

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print the version number of the application",
        Long:  `All software has versions. This is playground's`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                logger.Successln("Playground CLI v1.0.0")
        }</span>,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(versionCmd)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package installer

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/client-go/tools/portforward"
        "k8s.io/client-go/transport/spdy"
)

type ArgoInstaller struct {
        KubeConfig     string
        ClusterName    string
        ArgoNamespace  string
        ArgoServerPort int
        LocalPort      int
        ServerAddress  string
        k8sClient      *k8s.K8sClient
        httpClient     *http.Client
        authToken      string
        stopChannel    chan struct{}
        readyChannel   chan struct{}
}

type ArgoApplication struct {
        APIVersion string              `json:"apiVersion"`
        Kind       string              `json:"kind"`
        Metadata   ArgoMetadata        `json:"metadata"`
        Spec       ArgoApplicationSpec `json:"spec"`
}

type ArgoMetadata struct {
        Name      string `json:"name"`
        Namespace string `json:"namespace"`
}

type ArgoApplicationSpec struct {
        Project     string          `json:"project"`
        Source      ArgoSource      `json:"source"`
        Destination ArgoDestination `json:"destination"`
        SyncPolicy  *ArgoSyncPolicy `json:"syncPolicy,omitempty"`
}

type ArgoSource struct {
        RepoURL        string  `json:"repoURL"`
        Path           string  `json:"path"`
        TargetRevision string  `json:"targetRevision"`
        Chart          *string `json:"chart,omitempty"` // Optional, used for Helm charts
        Helm           *struct {
                ReleaseName  string `json:"releaseName,omitempty"`
                ValuesObject map[string]interface{}
        } `json:"helm,omitempty"` // Optional, used for Helm charts
}

type ArgoDestination struct {
        Server    string `json:"server"`
        Namespace string `json:"namespace"`
}

type ArgoSyncPolicy struct {
        Automated   *ArgoSyncPolicyAutomated `json:"automated,omitempty"`
        SyncOptions []string                 `json:"syncOptions,omitempty"`
}

type ArgoSyncPolicyAutomated struct {
        Prune    bool `json:"prune,omitempty"`
        SelfHeal bool `json:"selfHeal,omitempty"`
}

type ArgoSessionRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

type ArgoSessionResponse struct {
        Token string `json:"token"`
}

const (
        DefaultArgoNamespace  = "argocd"
        DefaultArgoServerPort = 443
        DefaultLocalPort      = 8080
)

func NewArgoInstaller(kubeConfig, clusterName string) (*ArgoInstaller, error) <span class="cov8" title="1">{
        k8sClient, err := k8s.NewK8sClient(kubeConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create k8s client: %w", err)
        }</span>

        <span class="cov8" title="1">httpClient := &amp;http.Client{
                Timeout: 30 * time.Second,
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},
                },
        }

        return &amp;ArgoInstaller{
                KubeConfig:     kubeConfig,
                ClusterName:    clusterName,
                ArgoNamespace:  DefaultArgoNamespace,
                ArgoServerPort: DefaultArgoServerPort,
                LocalPort:      DefaultLocalPort,
                k8sClient:      k8sClient,
                httpClient:     httpClient,
        }, nil</span>
}

func (a *ArgoInstaller) Install(options *InstallOptions) error <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">logger.Infoln("Starting ArgoCD application installation...")

        if err := a.connectToArgoCD(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to ArgoCD: %w", err)
        }</span>
        <span class="cov0" title="0">defer a.cleanup()

        if err := a.createApplication(options); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create ArgoCD application: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Infoln("Successfully created ArgoCD application: %s", options.ApplicationName)
        return nil</span>
}

func (a *ArgoInstaller) UnInstall(options *InstallOptions) error <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">logger.Infoln("Starting ArgoCD application uninstallation...")

        if err := a.connectToArgoCD(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to ArgoCD: %w", err)
        }</span>
        <span class="cov0" title="0">defer a.cleanup()

        if err := a.deleteApplication(options); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete ArgoCD application: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Infoln("Successfully deleted ArgoCD application: %s", options.ApplicationName)
        return nil</span>
}

func (a *ArgoInstaller) connectToArgoCD() error <span class="cov0" title="0">{
        password, err := a.GetAdminPassword()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get admin password: %w", err)
        }</span>

        <span class="cov0" title="0">if err := a.setupPortForward(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup port forward: %w", err)
        }</span>

        // Wait a bit longer for the port forward to be fully established
        <span class="cov0" title="0">logger.Infoln("Waiting for port forward to stabilize...")
        time.Sleep(5 * time.Second)

        // Retry authentication with backoff
        var authErr error
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                authErr = a.authenticate(password)
                if authErr == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">logger.Warnln("Authentication attempt %d failed: %v, retrying...", i+1, authErr)
                time.Sleep(time.Duration(i+1) * 2 * time.Second)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("failed to authenticate after 3 attempts: %w", authErr)</span>
}

func (a *ArgoInstaller) authenticate(password string) error <span class="cov0" title="0">{
        sessionReq := ArgoSessionRequest{
                Username: "admin",
                Password: password,
        }

        reqBody, err := json.Marshal(sessionReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal session request: %w", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("http://%s/api/v1/session", a.ServerAddress)
        req, err := http.NewRequest("POST", url, bytes.NewBuffer(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create session request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to authenticate: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("authentication failed: HTTP %d - %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var sessionResp ArgoSessionResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;sessionResp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode session response: %w", err)
        }</span>

        <span class="cov0" title="0">a.authToken = sessionResp.Token
        return nil</span>
}

func (a *ArgoInstaller) createApplication(options *InstallOptions) error <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">app := ArgoApplication{
                APIVersion: "argoproj.io/v1alpha1",
                Kind:       "Application",
                Metadata: ArgoMetadata{
                        Name:      options.ApplicationName,
                        Namespace: a.ArgoNamespace,
                },
                Spec: ArgoApplicationSpec{
                        Project: "default",
                        Source: ArgoSource{
                                RepoURL:        options.RepoURL,
                                Path:           options.Path,
                                TargetRevision: options.Version,
                        },
                        Destination: ArgoDestination{
                                Server:    "https://kubernetes.default.svc",
                                Namespace: options.Namespace,
                        },
                        SyncPolicy: &amp;ArgoSyncPolicy{
                                Automated: &amp;ArgoSyncPolicyAutomated{
                                        Prune:    true,
                                        SelfHeal: true,
                                },
                                SyncOptions: []string{"CreateNamespace=true"},
                        },
                },
        }
        if options.ChartName != nil </span><span class="cov0" title="0">{
                app.Spec.Source.Chart = options.ChartName
                app.Spec.Source.Helm.ReleaseName = options.ApplicationName
                app.Spec.Source.Helm.ValuesObject = options.Values
        }</span>

        <span class="cov0" title="0">if app.Spec.Source.Path == "" </span><span class="cov0" title="0">{
                app.Spec.Source.Path = "."
        }</span>
        <span class="cov0" title="0">if app.Spec.Source.TargetRevision == "" </span><span class="cov0" title="0">{
                app.Spec.Source.TargetRevision = "HEAD"
        }</span>

        <span class="cov0" title="0">reqBody, err := json.Marshal(app)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal application: %w", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("http://%s/api/v1/applications", a.ServerAddress)
        req, err := http.NewRequest("POST", url, bytes.NewBuffer(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create application request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+a.authToken)

        resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create application: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to create application: HTTP %d - %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *ArgoInstaller) deleteApplication(options *InstallOptions) error <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("http://%s/api/v1/applications/%s", a.ServerAddress, options.ApplicationName)
        req, err := http.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create delete request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+a.authToken)

        q := req.URL.Query()
        q.Add("cascade", "true")
        req.URL.RawQuery = q.Encode()

        resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete application: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusNoContent &amp;&amp; resp.StatusCode != http.StatusNotFound </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to delete application: HTTP %d - %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *ArgoInstaller) setupPortForward() error <span class="cov0" title="0">{
        podList, err := a.k8sClient.Clientset.CoreV1().Pods(a.ArgoNamespace).List(context.Background(), metav1.ListOptions{
                LabelSelector: labels.Set{"app.kubernetes.io/name": "argocd-server"}.String(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list ArgoCD server pods: %w", err)
        }</span>

        <span class="cov0" title="0">if len(podList.Items) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no ArgoCD server pods found in namespace %s", a.ArgoNamespace)
        }</span>

        <span class="cov0" title="0">pod := podList.Items[0]
        if pod.Status.Phase != corev1.PodRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("ArgoCD server pod is not running: %s", pod.Status.Phase)
        }</span>

        <span class="cov0" title="0">logger.Infoln("Setting up port forward to ArgoCD server pod: %s", pod.Name)
        req := a.k8sClient.Clientset.CoreV1().RESTClient().Post().
                Resource("pods").
                Namespace(a.ArgoNamespace).
                Name(pod.Name).
                SubResource("portforward")
        transport, upgrader, err := spdy.RoundTripperFor(a.k8sClient.Config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SPDY transport: %w", err)
        }</span>
        <span class="cov0" title="0">ports := []string{fmt.Sprintf("%d:8080", a.LocalPort)}

        a.stopChannel = make(chan struct{}, 1)
        a.readyChannel = make(chan struct{}, 1)
        out := &amp;bytes.Buffer{}
        errOut := &amp;bytes.Buffer{}
        dialer := spdy.NewDialer(upgrader, &amp;http.Client{Transport: transport}, "POST", req.URL())
        forwarder, err := portforward.New(
                dialer,
                ports,
                a.stopChannel,
                a.readyChannel,
                out,
                errOut,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create port forwarder: %w", err)
        }</span>

        <span class="cov0" title="0">errChan := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                if err := forwarder.ForwardPorts(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Port forwarding failed: %v", err)
                        errChan &lt;- err
                }</span>
        }()

        <span class="cov0" title="0">select </span>{
        case &lt;-a.readyChannel:<span class="cov0" title="0">
                logger.Infoln("Port forward established successfully")</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                close(a.stopChannel)
                return fmt.Errorf("port forwarding failed: %w", err)</span>
        case &lt;-time.After(15 * time.Second):<span class="cov0" title="0">
                close(a.stopChannel)
                return fmt.Errorf("timeout waiting for port forward to be ready")</span>
        }

        <span class="cov0" title="0">a.ServerAddress = fmt.Sprintf("localhost:%d", a.LocalPort)
        return nil</span>
}

func (a *ArgoInstaller) GetAdminPassword() (string, error) <span class="cov0" title="0">{
        secret, err := a.k8sClient.Clientset.CoreV1().Secrets(a.ArgoNamespace).Get(context.Background(), "argocd-initial-admin-secret", metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get ArgoCD admin secret: %w", err)
        }</span>

        <span class="cov0" title="0">password := string(secret.Data["password"])
        if password == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ArgoCD admin password not found in secret")
        }</span>

        <span class="cov0" title="0">return password, nil</span>
}

func (a *ArgoInstaller) ValidateArgoConnection() error <span class="cov8" title="1">{
        if a.ServerAddress == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no active connection to ArgoCD")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (a *ArgoInstaller) cleanup() <span class="cov8" title="1">{
        a.authToken = ""
        a.ServerAddress = ""
        if a.stopChannel != nil </span><span class="cov0" title="0">{
                logger.Infoln("Terminating port forward process...")
                close(a.stopChannel)
                a.stopChannel = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package installer

import (
        "context"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "time"

        "helm.sh/helm/v3/pkg/action"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/chart/loader"
        "helm.sh/helm/v3/pkg/cli"
        "helm.sh/helm/v3/pkg/getter"
        "helm.sh/helm/v3/pkg/repo"
)

var settings = cli.New()

func NewHelmInstaller() (*HelmInstaller, error) <span class="cov0" title="0">{
        return &amp;HelmInstaller{}, nil
}</span>

type HelmInstaller struct {
        KubeConfig string
}

func (h *HelmInstaller) Install(options *InstallOptions) error <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()
        actionConfig, err := h.createHelmActionConfig(options.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create helm action config: %w", err)
        }</span>

        <span class="cov0" title="0">histClient := action.NewHistory(actionConfig)
        histClient.Max = 1
        _, err = histClient.Run(options.ApplicationName)

        if err == nil </span><span class="cov0" title="0">{
                // Release exists, upgrade it
                upgrade := action.NewUpgrade(actionConfig)
                upgrade.Namespace = options.Namespace

                chart, err := h.downloadAndLoadChart(options)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to download and load chart: %w", err)
                }</span>

                <span class="cov0" title="0">rel, err := upgrade.RunWithContext(ctx, options.ApplicationName, chart, options.Values)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error upgrading chart: %v\n", err)
                        return fmt.Errorf("failed to upgrade chart: %w", err)
                }</span>

                <span class="cov0" title="0">if rel == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get release information")
                }</span>
        } else<span class="cov0" title="0"> {
                // Release doesn't exist, install it
                install := action.NewInstall(actionConfig)
                install.Namespace = options.Namespace
                install.ReleaseName = options.ApplicationName
                install.CreateNamespace = true

                chart, err := h.downloadAndLoadChart(options)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to download and load chart: %w", err)
                }</span>

                <span class="cov0" title="0">rel, err := install.RunWithContext(ctx, chart, options.Values)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error installing chart: %v\n", err)
                        return fmt.Errorf("failed to install chart: %w", err)
                }</span>

                <span class="cov0" title="0">if rel == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get release information")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (h *HelmInstaller) UnInstall(options *InstallOptions) error <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("install options cannot be nil")
        }</span>

        <span class="cov0" title="0">actionConfig, err := h.createHelmActionConfig(options.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create helm action config: %w", err)
        }</span>

        <span class="cov0" title="0">uninstall := action.NewUninstall(actionConfig)
        uninstall.Timeout = 5 * time.Minute
        uninstall.Wait = true

        _, err = uninstall.Run(options.ApplicationName)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error uninstalling chart: %v\n", err)
                return fmt.Errorf("failed to uninstall chart: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *HelmInstaller) createHelmActionConfig(namespace string) (*action.Configuration, error) <span class="cov0" title="0">{
        tmpPath := filepath.Join(os.TempDir(), fmt.Sprintf("kubeconfig-%d", time.Now().UnixNano()))

        if err := os.WriteFile(tmpPath, []byte(h.KubeConfig), 0o600); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write kubeconfig to temp file: %w", err)
        }</span>

        <span class="cov0" title="0">settings.KubeConfig = tmpPath
        actionConfig := new(action.Configuration)
        if err := actionConfig.Init(settings.RESTClientGetter(), namespace, os.Getenv("HELM_DRIVER"), log.Printf); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize helm action config: %w", err)
        }</span>

        <span class="cov0" title="0">return actionConfig, nil</span>
}

func (h *HelmInstaller) downloadAndLoadChart(options *InstallOptions) (*chart.Chart, error) <span class="cov0" title="0">{
        chartPathOptions := action.ChartPathOptions{
                RepoURL:            options.RepoURL,
                Version:            options.Version,
                PassCredentialsAll: true,
        }

        if err := h.addHelmRepo(options); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add helm repository: %w", err)
        }</span>

        <span class="cov0" title="0">chartPath, err := chartPathOptions.LocateChart(*options.ChartName, settings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to locate chart %s: %w", *options.ChartName, err)
        }</span>

        <span class="cov0" title="0">log.Printf("Chart found at: %s\n", chartPath)

        loadedChart, err := loader.Load(chartPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load chart from %s: %w", chartPath, err)
        }</span>

        <span class="cov0" title="0">if loadedChart.Metadata.Name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("chart has no name")
        }</span>

        <span class="cov0" title="0">if loadedChart.Metadata.Version == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("chart has no version")
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully loaded chart: %s version %s\n", loadedChart.Metadata.Name, loadedChart.Metadata.Version)

        return loadedChart, nil</span>
}

func (h *HelmInstaller) addHelmRepo(options *InstallOptions) error <span class="cov0" title="0">{
        entry := repo.Entry{
                Name: options.RepoName,
                URL:  options.RepoURL,
        }

        r, err := repo.NewChartRepository(&amp;entry, getter.All(settings))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create chart repository: %w", err)
        }</span>

        <span class="cov0" title="0">indexFilePath, err := r.DownloadIndexFile()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download repository index: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = repo.LoadIndexFile(indexFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load repository index: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package k8s

import (
        "context"

        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/rest"
)

type K8sClient struct {
        Clientset *kubernetes.Clientset
        Dynamic   *dynamic.DynamicClient
        Config    *rest.Config
}

func NewK8sClient(kubeConfig string) (*K8sClient, error) <span class="cov0" title="0">{
        restConfig, err := clientcmd.RESTConfigFromKubeConfig([]byte(kubeConfig))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">clientset, err := kubernetes.NewForConfig(restConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dynamicClient, err := dynamic.NewForConfig(restConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;K8sClient{
                Clientset: clientset,
                Dynamic:   dynamicClient,
                Config:    restConfig,
        }, nil</span>
}

func (k *K8sClient) GetNameSpace(name string, ctx context.Context) (string, error) <span class="cov0" title="0">{
        namespace, err := k.Clientset.CoreV1().Namespaces().Get(ctx, name, v1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return namespace.Name, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package multipass

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "strings"
        "sync"
        "time"

        "github.com/mrgb7/playground/pkg/logger"
)

// Client defines the interface for multipass operations
type Client interface {
        IsMultipassInstalled() bool
        CreateCluster(clusterName string, nodeCount int, wg *sync.WaitGroup) error
        DeleteCluster(clusterName string, wg *sync.WaitGroup) error
        CreateNode(name string, cpus int, memory string, disk string) error
        DeleteNode(name string) error
        PurgeNodes() error
        GetNodeIP(name string) (string, error)
        ExecuteShell(name string, command string) (string, error)
        ExecuteShellWithTimeout(name string, command string, timeoutSeconds int, envs ...string) (string, error)
}

type MultiPassList struct {
        List []MultiPassListItem `json:"list"`
}

type MultiPassListItem struct {
        Name string `json:"name"`
}

type MultiPassInfo struct {
        Errors []interface{}              `json:"errors"`
        Info   map[string]MultiPassNode   `json:"info"`
}

type MultiPassNode struct {
        IPv4 []string `json:"ipv4"`
}

type MultipassClient struct {
        BinaryPath string
}

const (
        DefaultMasterCPUs    = 2
        DefaultMasterMemory  = "2G"
        DefaultMasterDisk    = "10G"
        DefaultWorkerCPUs    = 1
        DefaultWorkerMemory  = "1G"
        DefaultWorkerDisk    = "5G"
)

func NewMultipassClient() *MultipassClient <span class="cov8" title="1">{
        return &amp;MultipassClient{
                BinaryPath: "multipass",
        }
}</span>

func (m *MultipassClient) IsMultipassInstalled() bool <span class="cov8" title="1">{
        cmd := exec.Command(m.BinaryPath, "--version")
        err := cmd.Run()
        return err == nil
}</span>

func (m *MultipassClient) CreateCluster(clusterName string, nodeCount int, wg *sync.WaitGroup) error <span class="cov0" title="0">{
        masterName := fmt.Sprintf("%s-master", clusterName)
        errChan := make(chan error, nodeCount)
        
        wg.Add(1)
        go func(name string) </span><span class="cov0" title="0">{
                defer wg.Done()
                err := m.CreateNode(name, DefaultMasterCPUs, DefaultMasterMemory, DefaultMasterDisk)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("failed to create master node %s: %v\n", name, err)
                        errChan &lt;- fmt.Errorf("failed to create master node %s: %w", name, err)
                        return
                }</span>
                <span class="cov0" title="0">logger.Debugln("Master node %s created successfully", name)</span>
        }(masterName)
        
        <span class="cov0" title="0">for i := 1; i &lt; nodeCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(workerIndex int) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        nodeName := fmt.Sprintf("%s-worker-%d", clusterName, workerIndex)
                        err := m.CreateNode(nodeName, DefaultWorkerCPUs, DefaultWorkerMemory, DefaultWorkerDisk)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("failed to create worker node %s: %v", nodeName, err)
                                errChan &lt;- fmt.Errorf("failed to create worker node %s: %w", nodeName, err)
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debugln("Worker node %s created successfully", nodeName)</span>
                }(i)
        }
        
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(errChan)
        }</span>()
        
        <span class="cov0" title="0">var creationErrors []error
        for err := range errChan </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        creationErrors = append(creationErrors, err)
                }</span>
        }
        
        <span class="cov0" title="0">if len(creationErrors) &gt; 0 </span><span class="cov0" title="0">{
                logger.Errorln("Error during cluster creation for '%s', attempting cleanup.", clusterName)
                
                var cleanupWG sync.WaitGroup
                if cleanupErr := m.DeleteCluster(clusterName, &amp;cleanupWG); cleanupErr != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Failed to cleanup cluster %s during error recovery: %v", clusterName, cleanupErr)
                }</span>
                
                <span class="cov0" title="0">return creationErrors[0]</span>
        }
        
        <span class="cov0" title="0">logger.Debugln("Cluster %s created successfully with %d total instances.", clusterName, nodeCount)
        return nil</span>
}

func (m *MultipassClient) DeleteCluster(clusterName string, wg *sync.WaitGroup) error <span class="cov0" title="0">{
        var list MultiPassList
        cmd := exec.Command(m.BinaryPath, "list", "--format", "json")
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list instances: %s - %w", stderr.String(), err)
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(stdout.Bytes(), &amp;list); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse JSON output: %w", err)
        }</span>
        
        <span class="cov0" title="0">var instancesToDelete []string
        for _, instance := range list.List </span><span class="cov0" title="0">{
                if strings.HasPrefix(instance.Name, clusterName) </span><span class="cov0" title="0">{
                        instancesToDelete = append(instancesToDelete, instance.Name)
                }</span>
        }
        
        <span class="cov0" title="0">errChan := make(chan error, len(instancesToDelete))
        
        for _, instanceName := range instancesToDelete </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(name string) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if err := m.DeleteNode(name); err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- fmt.Errorf("failed to delete node %s: %w", name, err)
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debugf("Successfully deleted node: %s", name)</span>
                }(instanceName)
        }
        
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(errChan)
        }</span>()
        
        <span class="cov0" title="0">var errors []error
        for err := range errChan </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, err)
                }</span>
        }
        
        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                var errMessages []string
                for _, err := range errors </span><span class="cov0" title="0">{
                        errMessages = append(errMessages, err.Error())
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("multiple deletion errors: %s", strings.Join(errMessages, "; "))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (m *MultipassClient) CreateNode(name string, cpus int, memory string, disk string) error <span class="cov8" title="1">{
        args := []string{
                "launch",
                "--name", name,
                "--cpus", fmt.Sprintf("%d", cpus),
                "--memory", memory,
                "--disk", disk,
        }

        logger.Debugln("Creating node: %s with %d CPUs, %s memory, %s disk", name, cpus, memory, disk)
        cmd := exec.Command(m.BinaryPath, args...)
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create node '%s': %s - %w", name, stderr.String(), err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *MultipassClient) DeleteNode(name string) error <span class="cov0" title="0">{
        cmd := exec.Command(m.BinaryPath, "delete", name)
        var stderr bytes.Buffer
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete node '%s': %s - %w", name, stderr.String(), err)
        }</span>

        <span class="cov0" title="0">logger.Debugln("Successfully deleted node '%s'", name)
        return nil</span>
}

func (m *MultipassClient) PurgeNodes() error <span class="cov0" title="0">{
        logger.Infoln("Purging deleted nodes")
        cmd := exec.Command(m.BinaryPath, "purge")
        var stderr bytes.Buffer
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to purge deleted instances: %s - %w", stderr.String(), err)
        }</span>

        <span class="cov0" title="0">logger.Successln("Successfully purged deleted nodes")
        return nil</span>
}

func (m *MultipassClient) GetNodeIP(name string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command(m.BinaryPath, "info", name, "--format", "json")
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get IP address for node '%s': %s - %w", name, stderr.String(), err)
        }</span>
        
        <span class="cov0" title="0">var data MultiPassInfo
        if err := json.Unmarshal(stdout.Bytes(), &amp;data); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse JSON output: %w", err)
        }</span>
        
        <span class="cov0" title="0">nodeInfo, exists := data.Info[name]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("node '%s' not found in multipass info", name)
        }</span>
        
        <span class="cov0" title="0">if len(nodeInfo.IPv4) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no IPv4 addresses found for node '%s'", name)
        }</span>
        
        <span class="cov0" title="0">ip := nodeInfo.IPv4[0]
        return ip, nil</span>
}

func (m *MultipassClient) ExecuteShell(name string, command string) (string, error) <span class="cov0" title="0">{
        return m.ExecuteShellWithTimeout(name, command, 0) // No timeout by default
}</span>

func (m *MultipassClient) ExecuteShellWithTimeout(name string, command string, timeoutSeconds int, envs ...string) (string, error) <span class="cov0" title="0">{
        ctx := context.Background()
        var cancel context.CancelFunc

        if timeoutSeconds &gt; 0 </span><span class="cov0" title="0">{
                ctx, cancel = context.WithTimeout(context.Background(), time.Duration(timeoutSeconds)*time.Second)
                defer cancel()
        }</span>

        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, m.BinaryPath, "exec", name, "--", "bash", "-c", command)
        cmd.Env = append(os.Environ(), envs...)
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                logger.Errorln("Failed to execute command on node '%s': %v", name, err)
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        return stdout.String(), fmt.Errorf("command timed out after %d seconds", timeoutSeconds)
                }</span>

                <span class="cov0" title="0">errMsg := fmt.Sprintf("Failed to execute shell command on node '%s': %s", name, stderr.String())
                logger.Errorln(errMsg)
                return "", fmt.Errorf("failed to execute shell command on node '%s': %s - %w", name, stderr.String(), err)</span>
        }

        <span class="cov0" title="0">return stdout.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package plugins

import (
        "context"
        "crypto/sha256"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"

        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
        "gopkg.in/yaml.v3"
)

type Argocd struct {
        KubeConfig string
        *BasePlugin
}

const (
        ArgocdRepoUrl       = "https://argoproj.github.io/argo-helm"
        ArgocdChartName     = "argo-cd"
        ArgocdChartVersion  = "8.0.0"
        ArgocdReleaseName   = "argocd"
        ArgocdNamespace     = "argocd"
        ArgoRepoName        = "argo"
        ArgocdValuesFileURL = "https://raw.githubusercontent.com/mrgb7/core-infrastructure/refs/heads/main/argocd/argocd-values-local.yaml"

        HTTPTimeoutSeconds = 30
        MaxResponseSize    = 10 * 1024 * 1024
)

func NewArgocd(kubeConfig string) *Argocd <span class="cov0" title="0">{
        argo := &amp;Argocd{
                KubeConfig: kubeConfig,
        }
        argo.BasePlugin = NewBasePlugin(kubeConfig, argo)
        return argo
}</span>

func (a *Argocd) GetName() string <span class="cov0" title="0">{
        return "argocd"
}</span>

func (a *Argocd) Install(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return a.BasePlugin.UnifiedInstall(kubeConfig, clusterName, ensure...)
}</span>

func (a *Argocd) Uninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return a.BasePlugin.UnifiedUninstall(kubeConfig, clusterName, ensure...)
}</span>

func (a *Argocd) getValuesContent() (map[string]interface{}, error) <span class="cov0" title="0">{
        if _, err := url.Parse(ArgocdValuesFileURL); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid values file URL: %w", err)
        }</span>

        <span class="cov0" title="0">httpClient := &amp;http.Client{
                Timeout: HTTPTimeoutSeconds * time.Second,
        }

        ctx, cancel := context.WithTimeout(context.Background(), HTTPTimeoutSeconds*time.Second)
        defer cancel()

        req, err := http.NewRequestWithContext(ctx, "GET", ArgocdValuesFileURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch values file: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch values file: HTTP %d %s", resp.StatusCode, resp.Status)
        }</span>

        <span class="cov0" title="0">limitedReader := io.LimitReader(resp.Body, MaxResponseSize)
        content, err := io.ReadAll(limitedReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov0" title="0">hash := sha256.Sum256(content)
        logger.Debugf("ArgoCD values file SHA256: %x", hash)

        var values map[string]interface{}
        if err := yaml.Unmarshal(content, &amp;values); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal YAML content: %w", err)
        }</span>

        <span class="cov0" title="0">return values, nil</span>
}

func (a *Argocd) Status() string <span class="cov0" title="0">{
        c, err := k8s.NewK8sClient(a.KubeConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to create k8s client: %v", err)
                return "UNKOWN"
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        ns, err := c.GetNameSpace(ArgocdNamespace, ctx)
        if ns == "" || err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to get argocd namespace: %v", err)
                return "Not installed"
        }</span>
        <span class="cov0" title="0">return "argocd is running"</span>
}

func (a *Argocd) GetNamespace() string <span class="cov0" title="0">{
        return ArgocdNamespace
}</span>

func (a *Argocd) GetVersion() string <span class="cov0" title="0">{
        return ArgocdChartVersion
}</span>

func (a *Argocd) GetChartName() string <span class="cov0" title="0">{
        return ArgocdChartName
}</span>

func (a *Argocd) GetRepository() string <span class="cov0" title="0">{
        return ArgocdRepoUrl
}</span>

func (a *Argocd) GetChartValues() map[string]interface{} <span class="cov0" title="0">{
        val, err := a.getValuesContent()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to get values content: %v", err)
                return nil
        }</span>
        <span class="cov0" title="0">return val</span>
}

func (a *Argocd) GetRepoName() string <span class="cov0" title="0">{
        return ArgoRepoName
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package plugins

import (
        "fmt"

        "github.com/mrgb7/playground/internal/installer"
)

type BasePlugin struct {
        KubeConfig string
        plugin     Plugin
}

func NewBasePlugin(kubeConfig string, plugin Plugin) *BasePlugin <span class="cov0" title="0">{
        return &amp;BasePlugin{
                KubeConfig: kubeConfig,
                plugin:     plugin,
        }
}</span>

func (b *BasePlugin) UnifiedInstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        inst, err := NewInstaller(b.plugin, kubeConfig, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create installer: %w", err)
        }</span>

        <span class="cov0" title="0">opts := newInstallOptions(b.plugin, kubeConfig)

        return inst.Install(opts)</span>
}

func (b *BasePlugin) UnifiedUninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        inst, err := NewInstaller(b.plugin, kubeConfig, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create installer: %w", err)
        }</span>
        <span class="cov0" title="0">opts := newInstallOptions(b.plugin, kubeConfig)
        return inst.UnInstall(opts)</span>
}

func newInstallOptions(plugin Plugin, kubeConfig string) *installer.InstallOptions <span class="cov0" title="0">{
        chartName := plugin.GetChartName()
        version := plugin.GetVersion()
        return &amp;installer.InstallOptions{
                Namespace:       plugin.GetNamespace(),
                Values:          plugin.GetChartValues(),
                ChartName:       &amp;chartName,
                RepoURL:         plugin.GetRepository(),
                ApplicationName: plugin.GetName(),
                Version:         version,
                KubeConfig:      kubeConfig,
                RepoName:        plugin.GetRepoName(),
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package plugins

import (
        "context"
        "time"

        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
)

type CertManager struct {
        KubeConfig string
        *BasePlugin
}

const (
        CertManagerRepoUrl      = "https://charts.jetstack.io"
        CertManagerChartName    = "cert-manager"
        CertManagerChartVersion = "v1.17.2"
        CertManagerReleaseName  = "cert-manager"
        CertManagerNamespace    = "cert-manager"
        CertManagerRepoName     = "jetstack"
)

func NewCertManager(kubeConfig string) *CertManager <span class="cov0" title="0">{
        cm := &amp;CertManager{
                KubeConfig: kubeConfig,
        }
        cm.BasePlugin = NewBasePlugin(kubeConfig, cm)
        return cm
}</span>

func (c *CertManager) GetName() string <span class="cov0" title="0">{
        return "cert-manager"
}</span>

func (c *CertManager) Install(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return c.BasePlugin.UnifiedInstall(kubeConfig, clusterName, ensure...)
}</span>

func (c *CertManager) Uninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return c.BasePlugin.UnifiedUninstall(kubeConfig, clusterName, ensure...)
}</span>

func (c *CertManager) getDefaultValues() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "crds": map[string]interface{}{
                        "enabled": true,
                },
                "prometheus": map[string]interface{}{
                        "enabled": true,
                },
                "webhook": map[string]interface{}{
                        "timeoutSeconds": 10,
                },
        }
}</span>

func (c *CertManager) Status() string <span class="cov0" title="0">{
        client, err := k8s.NewK8sClient(c.KubeConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to create k8s client: %v", err)
                return "UNKNOWN"
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        ns, err := client.GetNameSpace(CertManagerNamespace, ctx)
        if ns == "" || err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to get cert-manager namespace: %v", err)
                return "Not installed"
        }</span>
        <span class="cov0" title="0">return "cert-manager is running"</span>
}

func (c *CertManager) GetNamespace() string <span class="cov0" title="0">{
        return CertManagerNamespace
}</span>

func (c *CertManager) GetVersion() string <span class="cov0" title="0">{
        return CertManagerChartVersion
}</span>

func (c *CertManager) GetChartName() string <span class="cov0" title="0">{
        return CertManagerChartName
}</span>

func (c *CertManager) GetRepository() string <span class="cov0" title="0">{
        return CertManagerRepoUrl
}</span>

func (c *CertManager) GetChartValues() map[string]interface{} <span class="cov0" title="0">{
        return c.getDefaultValues()
}</span>

func (c *CertManager) GetReleaseName() string <span class="cov0" title="0">{
        return CertManagerReleaseName
}</span>

func (c *CertManager) GetRepoName() string <span class="cov0" title="0">{
        return CertManagerRepoName
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package plugins

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

const (
        repoUrl      = "https://metallb.github.io/metallb"
        chartName    = "metallb"
        chartVersion = "0.14.9"
        releaseName  = "metallb"
        namespace    = "metallb-system"
        repoName     = "metallb"
)

type LoadBalancer struct {
        KubeConfig      string
        k8sClient       *k8s.K8sClient
        MasterClusterIP string
        *BasePlugin
}

func NewLoadBalancer(kubeConfig string, masterClusterIP string) (*LoadBalancer, error) <span class="cov0" title="0">{
        c, err := k8s.NewK8sClient(kubeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create k8s client: %w", err)
        }</span>
        <span class="cov0" title="0">lb := &amp;LoadBalancer{
                KubeConfig:      kubeConfig,
                k8sClient:       c,
                MasterClusterIP: masterClusterIP,
        }
        lb.BasePlugin = NewBasePlugin(kubeConfig, lb)
        return lb, nil</span>
}

func (l *LoadBalancer) GetName() string <span class="cov0" title="0">{
        return "load-balancer"
}</span>

func (l *LoadBalancer) Install(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        err := l.BasePlugin.UnifiedInstall(kubeConfig, clusterName, ensure...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install loadbalancer: %w", err)
        }</span>
        <span class="cov0" title="0">err = l.deleteValidationWebhookConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete validation webhook config: %w", err)
        }</span>
        <span class="cov0" title="0">err = l.addl2IpPool()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add l2 ip pool: %w", err)
        }</span>
        <span class="cov0" title="0">err = l.addl2Adv()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add l2 advertisement: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (l *LoadBalancer) Uninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        logger.Infoln("Uninstalling loadbalancer")
        return l.BasePlugin.UnifiedUninstall(kubeConfig, clusterName, ensure...)
}</span>

func (l *LoadBalancer) Status() string <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        ns, err := l.k8sClient.GetNameSpace(namespace, ctx)
        if ns == "" || err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to get metallb namespace: %v", err)
                return "Not installed"
        }</span>

        <span class="cov0" title="0">return "LoadBalancer is running"</span>
}

func (l *LoadBalancer) addl2IpPool() error <span class="cov0" title="0">{
        ipRange, err := l.getIPRange()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to get ip range: %v", err)
                return fmt.Errorf("failed to get ip range: %w", err)
        }</span>
        <span class="cov0" title="0">ipPool := &amp;unstructured.Unstructured{
                Object: map[string]interface{}{
                        "apiVersion": "metallb.io/v1beta1",
                        "kind":       "IPAddressPool",
                        "metadata": map[string]interface{}{
                                "name":      "k3s-pool-ip",
                                "namespace": "metallb-system",
                        },
                        "spec": map[string]interface{}{
                                "addresses": []interface{}{ipRange},
                        },
                },
        }
        ipPool.SetGroupVersionKind(schema.GroupVersionKind{
                Group:   "metallb.io",
                Version: "v1beta1",
                Kind:    "IPAddressPool",
        })
        ipPooRes := schema.GroupVersionResource{
                Group:    "metallb.io",
                Version:  "v1beta1",
                Resource: "ipaddresspools",
        }
        _, err = l.k8sClient.Dynamic.Resource(ipPooRes).
                Namespace(namespace).
                Create(context.TODO(), ipPool, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to create ip address pool: %v", err)
                return fmt.Errorf("failed to create ip address pool: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (l *LoadBalancer) addl2Adv() error <span class="cov0" title="0">{
        l2Adv := &amp;unstructured.Unstructured{
                Object: map[string]interface{}{
                        "apiVersion": "metallb.io/v1beta1",
                        "kind":       "L2Advertisement",
                        "metadata": map[string]interface{}{
                                "name":      "k3s-lb-pool",
                                "namespace": "metallb-system",
                        },
                        "spec": map[string]interface{}{
                                "ipAddressPools": []interface{}{"k3s-pool-ip"},
                        },
                },
        }
        l2Adv.SetGroupVersionKind(schema.GroupVersionKind{
                Group:   "metallb.io",
                Version: "v1beta1",
                Kind:    "L2Advertisement",
        })

        l2AdvRes := schema.GroupVersionResource{
                Group:    "metallb.io",
                Version:  "v1beta1",
                Resource: "l2advertisements",
        }

        _, err := l.k8sClient.Dynamic.Resource(l2AdvRes).
                Namespace(namespace).
                Create(context.TODO(), l2Adv, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("failed to create l2 advertisement: %v", err)
                return fmt.Errorf("failed to create l2 advertisement: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (l *LoadBalancer) deleteValidationWebhookConfig() error <span class="cov0" title="0">{
        return l.k8sClient.Clientset.AdmissionregistrationV1().
                ValidatingWebhookConfigurations().
                Delete(context.TODO(), "metallb-webhook-configuration", metav1.DeleteOptions{})
}</span>

func (l *LoadBalancer) getIPRange() (string, error) <span class="cov0" title="0">{
        ipParts := strings.Split(l.MasterClusterIP, ".")
        dhcp := ipParts[:3]
        start := fmt.Sprintf("%s.100", strings.Join(dhcp, "."))
        end := fmt.Sprintf("%s.200", strings.Join(dhcp, "."))
        return fmt.Sprintf("%s-%s", start, end), nil
}</span>

func (l *LoadBalancer) GetNamespace() string <span class="cov0" title="0">{
        return namespace
}</span>

func (l *LoadBalancer) GetVersion() string <span class="cov0" title="0">{
        return chartVersion
}</span>

func (l *LoadBalancer) GetChartName() string <span class="cov0" title="0">{
        return chartName
}</span>

func (l *LoadBalancer) GetRepository() string <span class="cov0" title="0">{
        return repoUrl
}</span>

func (l *LoadBalancer) GetChartValues() map[string]interface{} <span class="cov0" title="0">{
        return make(map[string]interface{})
}</span>

func (l *LoadBalancer) GetRepoName() string <span class="cov0" title="0">{
        return repoName
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package plugins

import "github.com/mrgb7/playground/internal/installer"

type Nginx struct{}

func (n *Nginx) GetName() string <span class="cov0" title="0">{
        return "nginx"
}</span>

func (n *Nginx) GetInstaller() (installer.Installer, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (n *Nginx) Install(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return nil
}</span>

func (n *Nginx) Uninstall(kubeConfig, clusterName string, ensure ...bool) error <span class="cov0" title="0">{
        return nil
}</span>

func (n *Nginx) Status() string <span class="cov0" title="0">{
        return "nginx is running"
}</span>

func (n *Nginx) GetNamespace() string <span class="cov0" title="0">{
        return "nginx"
}</span>

func (n *Nginx) GetVersion() string <span class="cov0" title="0">{
        return "1.21.6"
}</span>

func (n *Nginx) GetChartName() string <span class="cov0" title="0">{
        return "nginx-ingress"
}</span>

func (n *Nginx) GetRepository() string <span class="cov0" title="0">{
        return "https://kubernetes.github.io/ingress-nginx"
}</span>

func (n *Nginx) GetRepoName() string <span class="cov0" title="0">{
        return "ingress-nginx"
}</span>

func (n *Nginx) GetChartValues() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "controller": map[string]interface{}{
                        "replicaCount": 2,
                        "service": map[string]interface{}{
                                "type": "LoadBalancer",
                        },
                        "config": map[string]interface{}{
                                "enable-vts-status": "true",
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package plugins

type Plugin interface {
        GetName() string
        Install(kubeConfig, clusterName string, ensure ...bool) error
        Uninstall(kubeConfig, clusterName string, ensure ...bool) error
        Status() string
        GetNamespace() string
        GetVersion() string
        GetChartName() string
        GetRepository() string
        GetRepoName() string
        GetChartValues() map[string]interface{}
}

func CreatePluginsList(kubeConfig, masterClusterIP string) ([]Plugin, error) <span class="cov0" title="0">{
        lb, err := NewLoadBalancer(kubeConfig, masterClusterIP)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return []Plugin{
                NewArgocd(kubeConfig),
                NewCertManager(kubeConfig),
                lb,
                &amp;Nginx{},
        }, nil</span>
}

var List = []Plugin{
        &amp;Argocd{},
        &amp;CertManager{},
        &amp;LoadBalancer{},
        &amp;Nginx{},
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package plugins

import (
        "context"
        "time"

        "github.com/mrgb7/playground/internal/installer"
        "github.com/mrgb7/playground/internal/k8s"
        "github.com/mrgb7/playground/pkg/logger"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        ArgocdInstallNamespace    = "argocd"
        ArgocdServerLabelSelector = "app.kubernetes.io/name=argocd-server"
)

func IsArgoCDRunning(kubeConfig string) bool <span class="cov8" title="1">{
        client, err := k8s.NewK8sClient(kubeConfig)
        if err != nil </span><span class="cov8" title="1">{
                logger.Debugln("Failed to create k8s client: %v", err)
                return false
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        namespace, err := client.GetNameSpace(ArgocdInstallNamespace, ctx)
        if err != nil || namespace == "" </span><span class="cov8" title="1">{
                logger.Debugln("ArgoCD namespace not found: %v", err)
                return false
        }</span>

        <span class="cov0" title="0">podList, err := client.Clientset.CoreV1().Pods(ArgocdInstallNamespace).List(ctx, metav1.ListOptions{
                LabelSelector: ArgocdServerLabelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Debugln("Failed to list ArgoCD server pods: %v", err)
                return false
        }</span>

        <span class="cov0" title="0">if len(podList.Items) == 0 </span><span class="cov0" title="0">{
                logger.Debugln("No ArgoCD server pods found")
                return false
        }</span>

        <span class="cov0" title="0">for _, pod := range podList.Items </span><span class="cov0" title="0">{
                if pod.Status.Phase == "Running" </span><span class="cov0" title="0">{
                        readyContainers := 0
                        totalContainers := len(pod.Status.ContainerStatuses)

                        for _, containerStatus := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                                if containerStatus.Ready </span><span class="cov0" title="0">{
                                        readyContainers++
                                }</span>
                        }

                        <span class="cov0" title="0">if readyContainers == totalContainers &amp;&amp; totalContainers &gt; 0 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">logger.Debugln("ArgoCD pods are not ready")
        return false</span>
}

func NewInstaller(plugin Plugin, kubeConfig, clusterName string) (installer.Installer, error) <span class="cov8" title="1">{
        if IsArgoCDRunning(kubeConfig) </span><span class="cov0" title="0">{
                argoInstaller, err := installer.NewArgoInstaller(kubeConfig, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Failed to create ArgoCD installer: %v", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">return argoInstaller, nil</span>
        }

        <span class="cov8" title="1">return installer.NewHelmInstaller()</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package main

import (
        "github.com/mrgb7/playground/cmd/root"
)

func main() <span class="cov0" title="0">{
        root.Execute()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package logger

import (
        "fmt"
        "io"
        "os"

        "github.com/fatih/color"
)

var (
        infoColor    = color.New(color.FgGreen)
        warnColor    = color.New(color.FgYellow)
        errorColor   = color.New(color.FgRed)
        debugColor   = color.New(color.FgCyan)
        successColor = color.New(color.FgGreen, color.Bold)
)

// Info prints info message with format
func Info(format string, args ...interface{}) <span class="cov8" title="1">{
        infoColor.Printf(format, args...)
}</span>

// Infof is an alias for Info for consistency
func Infof(format string, args ...interface{}) <span class="cov0" title="0">{
        Info(format, args...)
}</span>

// Infoln prints info message with newline
func Infoln(format string, args ...interface{}) <span class="cov8" title="1">{
        infoColor.Printf(format+"\n", args...)
}</span>

// Warn prints warning message with format
func Warn(format string, args ...interface{}) <span class="cov8" title="1">{
        warnColor.Printf(format, args...)
}</span>

// Warnf is an alias for Warn for consistency
func Warnf(format string, args ...interface{}) <span class="cov0" title="0">{
        Warn(format, args...)
}</span>

// Warnln prints warning message with newline
func Warnln(format string, args ...interface{}) <span class="cov8" title="1">{
        warnColor.Printf(format+"\n", args...)
}</span>

// Error prints error message with format
func Error(format string, args ...interface{}) <span class="cov8" title="1">{
        errorColor.Printf(format, args...)
}</span>

// Errorf is an alias for Error for consistency
func Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        Error(format, args...)
}</span>

// Errorln prints error message with newline
func Errorln(format string, args ...interface{}) <span class="cov8" title="1">{
        errorColor.Printf(format+"\n", args...)
}</span>

// Debug prints debug message with format
func Debug(format string, args ...interface{}) <span class="cov8" title="1">{
        debugColor.Printf(format, args...)
}</span>

// Debugf is an alias for Debug for consistency
func Debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        Debug(format, args...)
}</span>

// Debugln prints debug message with newline
func Debugln(format string, args ...interface{}) <span class="cov8" title="1">{
        debugColor.Printf(format+"\n", args...)
}</span>

// Success prints success message with format
func Success(format string, args ...interface{}) <span class="cov8" title="1">{
        successColor.Printf(format, args...)
}</span>

// Successf is an alias for Success for consistency
func Successf(format string, args ...interface{}) <span class="cov0" title="0">{
        Success(format, args...)
}</span>

// Successln prints success message with newline
func Successln(format string, args ...interface{}) <span class="cov8" title="1">{
        successColor.Printf(format+"\n", args...)
}</span>

// Fatal prints error message and exits
func Fatal(format string, args ...interface{}) <span class="cov0" title="0">{
        errorColor.Printf(format+"\n", args...)
        os.Exit(1)
}</span>

// Print prints plain message with format
func Print(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf(format, args...)
}</span>

// Println prints plain message with newline
func Println(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf(format+"\n", args...)
}</span>

// GetWriter returns an io.Writer for use with external libraries
func GetWriter() io.Writer <span class="cov0" title="0">{
        return os.Stdout
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package types

import (
        "fmt"
        "strings"

        "github.com/mrgb7/playground/internal/multipass"
)

type Cluster struct {
        Name       string
        Nodes      []*Node
        KubeConfig string
}

func Get(clusterName string, load *bool) *Cluster <span class="cov0" title="0">{
        return nil
}</span>

func (c *Cluster) GetMaster() *Node <span class="cov0" title="0">{
        for _, node := range c.Nodes </span><span class="cov0" title="0">{
                if strings.HasSuffix(node.Name, "master") </span><span class="cov0" title="0">{
                        return node
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (c *Cluster) GetWorkers() []*Node <span class="cov0" title="0">{
        workers := []*Node{}
        for _, node := range c.Nodes </span><span class="cov0" title="0">{
                if !strings.HasSuffix(node.Name, "master") </span><span class="cov0" title="0">{
                        workers = append(workers, node)
                }</span>
        }
        <span class="cov0" title="0">return workers</span>
}

func (c *Cluster) SetKubeConfig() error <span class="cov0" title="0">{
        masterNodeName := fmt.Sprintf("%s-master", c.Name)
        cl := multipass.NewMultipassClient()
        masterIP, err := cl.GetNodeIP(masterNodeName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get master node IP: %w", err)
        }</span>
        <span class="cov0" title="0">res, err := cl.ExecuteShell(masterNodeName, "sudo cat /etc/rancher/k3s/k3s.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get kubeconfig: %w", err)
        }</span>
        <span class="cov0" title="0">res = strings.ReplaceAll(res, "127.0.0.1", masterIP)
        c.KubeConfig = res
        return nil</span>
}

func (c *Cluster) GetMasterIP() string <span class="cov0" title="0">{
        masterNodeName := fmt.Sprintf("%s-master", c.Name)
        cl := multipass.NewMultipassClient()
        masterIP, err := cl.GetNodeIP(masterNodeName)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return masterIP</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
